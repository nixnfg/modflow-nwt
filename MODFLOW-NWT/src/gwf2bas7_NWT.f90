MODULE GLOBAL
   PARAMETER(NIUNIT=100)
   INTEGER, SAVE, POINTER    ::NCOL,NROW,NLAY,NPER,NBOTM,NCNFBD
   INTEGER, SAVE, POINTER    ::ITMUNI,LENUNI,IXSEC,ITRSS,INBAS
   INTEGER, SAVE, POINTER    ::IFREFM,NODES,IOUT,MXITER
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::IUNIT(:)
   DOUBLE PRECISION, SAVE, DIMENSION(:,:,:), POINTER ::HNEW
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::LBOTM
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::LAYCBD
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::LAYHDT
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::LAYHDS
   REAL,    SAVE,    DIMENSION(:),     POINTER ::PERLEN
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::NSTP
   REAL,    SAVE,    DIMENSION(:),     POINTER ::TSMULT
   INTEGER, SAVE,    DIMENSION(:),     POINTER ::ISSFLG
   REAL,    SAVE,    DIMENSION(:),     POINTER ::DELR
   REAL,    SAVE,    DIMENSION(:),     POINTER ::DELC
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::BOTM
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::HOLD
   INTEGER, SAVE,    DIMENSION(:,:,:), POINTER ::IBOUND
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::CR
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::CC
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::CV
   DOUBLE PRECISION,    SAVE,    DIMENSION(:,:,:), POINTER ::HCOF
   DOUBLE PRECISION,    SAVE,    DIMENSION(:,:,:), POINTER ::RHS
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::BUFF
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::STRT
   REAL,    SAVE,    DIMENSION(:,:,:), POINTER ::DDREF
   TYPE GLOBALTYPE
      INTEGER,POINTER    :: NCOL,NROW,NLAY,NPER,NBOTM,NCNFBD
      INTEGER,POINTER    :: ITMUNI,LENUNI,IXSEC,ITRSS,INBAS
      INTEGER,POINTER    :: IFREFM,NODES,IOUT,MXITER
      INTEGER,    DIMENSION(:),     POINTER ::IUNIT
      DOUBLE PRECISION, DIMENSION(:,:,:), POINTER ::HNEW
      INTEGER,    DIMENSION(:),     POINTER ::LBOTM
      INTEGER,    DIMENSION(:),     POINTER ::LAYCBD
      INTEGER,    DIMENSION(:),     POINTER ::LAYHDT
      INTEGER,    DIMENSION(:),     POINTER ::LAYHDS
      REAL,       DIMENSION(:),     POINTER ::PERLEN
      INTEGER,    DIMENSION(:),     POINTER ::NSTP
      REAL,       DIMENSION(:),     POINTER ::TSMULT
      INTEGER,    DIMENSION(:),     POINTER ::ISSFLG
      REAL,       DIMENSION(:),     POINTER ::DELR
      REAL,       DIMENSION(:),     POINTER ::DELC
      REAL,       DIMENSION(:,:,:), POINTER ::BOTM
      REAL,       DIMENSION(:,:,:), POINTER ::HOLD
      INTEGER,    DIMENSION(:,:,:), POINTER ::IBOUND
      REAL,       DIMENSION(:,:,:), POINTER ::CR
      REAL,       DIMENSION(:,:,:), POINTER ::CC
      REAL,       DIMENSION(:,:,:), POINTER ::CV
      DOUBLE PRECISION,       DIMENSION(:,:,:), POINTER ::HCOF
      DOUBLE PRECISION,       DIMENSION(:,:,:), POINTER ::RHS
      REAL,       DIMENSION(:,:,:), POINTER ::BUFF
      REAL,       DIMENSION(:,:,:), POINTER ::STRT
      REAL,       DIMENSION(:,:,:), POINTER ::DDREF
   END TYPE GLOBALTYPE
   TYPE(GLOBALTYPE),SAVE ::GLOBALDAT(10)
END MODULE GLOBAL
MODULE PARAMMODULE
   !  Data definitions for Named Parameters
   !  Explicitly declare all variables to enable subroutines that include
   !  this file to use the IMPLICIT NONE statement.
   PARAMETER (MXPAR=2000,MXCLST=20000,MXINST=50000)
   INTEGER,SAVE,POINTER ::ICLSUM,IPSUM,INAMLOC,NMLTAR,NZONAR,NPVAL
   REAL,          SAVE,    DIMENSION(:),    POINTER ::B
   INTEGER,       SAVE,    DIMENSION(:),    POINTER ::IACTIVE
   INTEGER,       SAVE,    DIMENSION(:,:),  POINTER ::IPLOC
   INTEGER,       SAVE,    DIMENSION(:,:),  POINTER ::IPCLST
   INTEGER,       SAVE,    DIMENSION(:,:,:),POINTER ::IZON
   REAL,          SAVE,    DIMENSION(:,:,:),POINTER ::RMLT
   CHARACTER(LEN=10),SAVE, DIMENSION(:),    POINTER ::PARNAM
   CHARACTER(LEN=4), SAVE, DIMENSION(:),    POINTER ::PARTYP
   CHARACTER(LEN=10),SAVE, DIMENSION(:),    POINTER ::ZONNAM
   CHARACTER(LEN=10),SAVE, DIMENSION(:),    POINTER ::MLTNAM
   CHARACTER(LEN=10),SAVE, DIMENSION(:),    POINTER ::INAME
   TYPE PARAMTYPE
      INTEGER,POINTER  ::ICLSUM,IPSUM,INAMLOC,NMLTAR,NZONAR,NPVAL
      REAL,              DIMENSION(:),    POINTER ::B
      INTEGER,           DIMENSION(:),    POINTER ::IACTIVE
      INTEGER,           DIMENSION(:,:),  POINTER ::IPLOC
      INTEGER,           DIMENSION(:,:),  POINTER ::IPCLST
      INTEGER,           DIMENSION(:,:,:),POINTER ::IZON
      REAL,              DIMENSION(:,:,:),POINTER ::RMLT
      CHARACTER(LEN=10), DIMENSION(:),    POINTER ::PARNAM
      CHARACTER(LEN=4),  DIMENSION(:),    POINTER ::PARTYP
      CHARACTER(LEN=10), DIMENSION(:),    POINTER ::ZONNAM
      CHARACTER(LEN=10), DIMENSION(:),    POINTER ::MLTNAM
      CHARACTER(LEN=10), DIMENSION(:),    POINTER ::INAME
   END TYPE
   TYPE(PARAMTYPE), SAVE  ::PARAMDAT(10)
END MODULE PARAMMODULE
MODULE GWFBASMODULE
   INTEGER, SAVE, POINTER  ::MSUM
   INTEGER, SAVE, POINTER  ::IHEDFM,IHEDUN,IDDNFM,IDDNUN,IBOUUN
   INTEGER, SAVE, POINTER  ::LBHDSV,LBDDSV,LBBOSV
   INTEGER, SAVE, POINTER  ::IBUDFL,ICBCFL,IHDDFL,IAUXSV,IBDOPT
   INTEGER, SAVE, POINTER  ::IPRTIM,IPEROC,ITSOC,ICHFLG
   INTEGER, SAVE, POINTER  ::IDDREF,IDDREFNEW
   REAL,    SAVE, POINTER  ::DELT,PERTIM,TOTIM,HNOFLO,HDRY,STOPER
   CHARACTER(LEN=20), SAVE, POINTER   ::CHEDFM,CDDNFM,CBOUFM
   INTEGER,           SAVE, DIMENSION(:,:), POINTER ::IOFLG
   REAL,              SAVE, DIMENSION(:,:), POINTER ::VBVL
   CHARACTER(LEN=20), SAVE, DIMENSION(:),   POINTER ::VBNM
   TYPE GWFBASTYPE
      INTEGER, POINTER  ::MSUM
      INTEGER, POINTER  ::IHEDFM,IHEDUN,IDDNFM,IDDNUN,IBOUUN
      INTEGER, POINTER  ::LBHDSV,LBDDSV,LBBOSV
      INTEGER, POINTER  ::IBUDFL,ICBCFL,IHDDFL,IAUXSV,IBDOPT
      INTEGER, POINTER  ::IPRTIM,IPEROC,ITSOC,ICHFLG
      INTEGER, POINTER  ::IDDREF,IDDREFNEW
      REAL,    POINTER  ::DELT,PERTIM,TOTIM,HNOFLO,HDRY,STOPER
      CHARACTER(LEN=20), POINTER   ::CHEDFM,CDDNFM,CBOUFM
      INTEGER,           DIMENSION(:,:), POINTER ::IOFLG
      REAL,              DIMENSION(:,:), POINTER ::VBVL
      CHARACTER(LEN=20), DIMENSION(:),   POINTER ::VBNM
   END TYPE
   TYPE(GWFBASTYPE), SAVE  ::GWFBASDAT(10)
END MODULE GWFBASMODULE


SUBROUTINE GWF2BAS7AR(INUNIT,CUNIT,VERSION,IUDIS,IUZON,IUMLT,&
&MAXUNIT,IGRID,IUOC,HEADNG,IUPVAL,MFVNAM)
   !     ******************************************************************
   !     Allocate and Read for GWF Basic Package
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,     ONLY:NCOL,NROW,NLAY,NPER,NBOTM,NCNFBD,ITMUNI,&
   &LENUNI,IXSEC,ITRSS,INBAS,IFREFM,NODES,IOUT,&
   &MXITER,IUNIT,NIUNIT,HNEW,LBOTM,LAYCBD,LAYHDT,&
   &LAYHDS,PERLEN,NSTP,TSMULT,ISSFLG,DELR,DELC,&
   &BOTM,HOLD,IBOUND,CR,CC,CV,HCOF,RHS,BUFF,STRT,&
   &DDREF
   USE PARAMMODULE,ONLY:MXPAR,MXCLST,MXINST,ICLSUM,IPSUM,&
   &INAMLOC,NMLTAR,NZONAR,NPVAL,&
   &B,IACTIVE,IPLOC,IPCLST,PARNAM,PARTYP,&
   &ZONNAM,MLTNAM,INAME
   USE GWFBASMODULE,ONLY:MSUM,IHEDFM,IHEDUN,IDDNFM,IDDNUN,IBOUUN,&
   &LBHDSV,LBDDSV,LBBOSV,IBUDFL,ICBCFL,IHDDFL,&
   &IAUXSV,IBDOPT,IPRTIM,IPEROC,ITSOC,ICHFLG,&
   &IDDREF,IDDREFNEW,DELT,PERTIM,TOTIM,HNOFLO,&
   &HDRY,STOPER,CHEDFM,CDDNFM,CBOUFM,VBVL,VBNM
   !
   CHARACTER*4 CUNIT(NIUNIT)
   CHARACTER*(*) VERSION
   CHARACTER*80 HEADNG(2)
   CHARACTER*(*) MFVNAM
   CHARACTER*200 LINE
   !
   DOUBLE PRECISION HNF
   CHARACTER*24 ANAME(2)
   DATA ANAME(1) /'          BOUNDARY ARRAY'/
   DATA ANAME(2) /'            INITIAL HEAD'/
   !     ------------------------------------------------------------------
   !1------Allocate scalar variables, which makes it possible for multiple
   !1------grids to be defined.
   ALLOCATE(NCOL,NROW,NLAY,NPER,NBOTM,NCNFBD,ITMUNI,LENUNI,ITRSS)
   ALLOCATE(IXSEC,INBAS,IFREFM,NODES,IOUT,MXITER)
   MXITER=1
   ALLOCATE(IUNIT(NIUNIT))
   !
   ALLOCATE(ICLSUM,IPSUM,INAMLOC,NMLTAR,NZONAR,NPVAL)
   ALLOCATE (B(MXPAR))
   ALLOCATE (IACTIVE(MXPAR))
   ALLOCATE (IPLOC(4,MXPAR))
   ALLOCATE (IPCLST(14,MXCLST))
   ALLOCATE (PARNAM(MXPAR))
   ALLOCATE (PARTYP(MXPAR))
   ALLOCATE (INAME(MXINST))
   !
   ALLOCATE(MSUM,IHEDFM,IHEDUN,IDDNFM,IDDNUN,IBOUUN,LBHDSV,LBDDSV,&
   &LBBOSV)
   ALLOCATE(IBUDFL,ICBCFL,IHDDFL,IAUXSV,IBDOPT,IPRTIM,IPEROC,ITSOC,&
   &ICHFLG,IDDREF,IDDREFNEW)
   ALLOCATE(DELT,PERTIM,TOTIM,HNOFLO,HDRY,STOPER)
   ALLOCATE(CHEDFM,CDDNFM,CBOUFM)
   HDRY=1.E30
   STOPER=0.0
   !
   !2------Open all files in name file.
   CALL SGWF2BAS7OPEN(INUNIT,IOUT,IUNIT,CUNIT,NIUNIT,&
   &VERSION,INBAS,MAXUNIT,MFVNAM)
   !
   !3------PRINT A MESSAGE IDENTIFYING THE BASIC PACKAGE.
   WRITE(IOUT,1)INBAS
1  FORMAT(1X,/1X,'BAS -- BASIC PACKAGE, VERSION 1.3.0, 7/01/2022',&
   &' INPUT READ FROM UNIT ',I4)
   !
   !3A-----SHOW PRECISION OF VARIABLES
   IPBUFF=PRECISION(BUFF)
   IPHNEW=PRECISION(HNEW)
   WRITE(IOUT,*)
   IF(IPBUFF.NE.IPHNEW) THEN
      WRITE(IOUT,*) 'MODFLOW was compiled using mixed precision'
      WRITE(IOUT,*) 'Precision of REAL variables:',IPBUFF
      WRITE(IOUT,*) 'Precision of DOUBLE PRECISION variables:',IPHNEW
   ELSE
      WRITE(IOUT,*) 'MODFLOW was compiled using uniform precision'
      WRITE(IOUT,*)&
      &'Precision of REAL and DOUBLE PRECISION variables:',IPBUFF
   END IF
   !
   !4------Initialize parameter definition variables.
   IPSUM=0
   ICLSUM=0
   INAMLOC=1
   DO 10 N=1,MXPAR
      PARNAM(N)=' '
      PARTYP(N)=' '
      IPLOC(1,N)=0
      IPLOC(2,N)=0
      IACTIVE(N)=0
10 CONTINUE
   !
   !5------Allocate and read discretization data.
   CALL SGWF2BAS7ARDIS(IUDIS,IOUT)
   NODES=NCOL*NROW*NLAY
   !
   !6------Allocate space for global arrays except discretization data.
   ALLOCATE (HNEW(NCOL,NROW,NLAY))
   ALLOCATE (HOLD(NCOL,NROW,NLAY))
   ALLOCATE (IBOUND(NCOL,NROW,NLAY))
   ALLOCATE (CR(NCOL,NROW,NLAY))
   ALLOCATE (CC(NCOL,NROW,NLAY))
   ALLOCATE (CV(NCOL,NROW,NLAY))
   ALLOCATE (HCOF(NCOL,NROW,NLAY))
   ALLOCATE (RHS(NCOL,NROW,NLAY))
   ALLOCATE (BUFF(NCOL,NROW,NLAY))
   ALLOCATE (STRT(NCOL,NROW,NLAY))
   DDREF=>STRT
   ALLOCATE (LAYHDT(NLAY))
   ALLOCATE (LAYHDS(NLAY))
   !
   !7------Initialize head-dependent thickness indicator to code that
   !7------indicates layer is undefined.
   DO 100 I=1,NLAY
      LAYHDT(I)=-1
      LAYHDS(I)=-1
100 CONTINUE
   WRITE(IOUT,'(//)')
   !
   !8------Read BAS Package file.
   !8A-----READ AND PRINT COMMENTS.  SAVE THE FIRST TWO COMMENTS IN HEADNG.
   HEADNG(1)=' '
   HEADNG(2)=' '
   WRITE(IOUT,*)
   READ(INBAS,'(A)') LINE
   IF(LINE(1:1).NE.'#') GO TO 20
   HEADNG(1)=LINE(1:80)
   WRITE(IOUT,'(1X,A)') HEADNG(1)
   READ(INBAS,'(A)') LINE
   IF(LINE(1:1).NE.'#') GO TO 20
   HEADNG(2)=LINE(1:80)
   WRITE(IOUT,'(1X,A)') HEADNG(2)
   CALL URDCOM(INBAS,IOUT,LINE)
   !
   !8B-----LOOK FOR OPTIONS IN THE FIRST ITEM AFTER THE HEADING.
20 IXSEC=0
   ICHFLG=0
   IFREFM=0
   IPRTIM=0
   STOPER=0.0
   LLOC=1
25 CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INBAS)
   IF(LINE(ISTART:ISTOP).EQ.'XSECTION') THEN
      IXSEC=1
   ELSE IF(LINE(ISTART:ISTOP).EQ.'CHTOCH') THEN
      ICHFLG=1
   ELSE IF(LINE(ISTART:ISTOP).EQ.'FREE') THEN
      IFREFM=1
      WRITE(IOUT,26)
26    FORMAT (1X,'THE FREE FORMAT OPTION HAS BEEN SELECTED')
   ELSE IF(LINE(ISTART:ISTOP).EQ.'PRINTTIME') THEN
      IPRTIM=1
      WRITE(IOUT,7)
7     FORMAT(1X,'THE PRINTTIME OPTION HAS BEEN SELECTED')
   ELSE IF(LINE(ISTART:ISTOP).EQ.'STOPERROR') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,N,STOPER,IOUT,INBAS)
      WRITE(IOUT,8) STOPER
8     FORMAT(1X,'When solver convergence criteria are not met,',/&
      &1X,'execution will continue unless the budget percent',/&
      &1X,'discrepancy is greater than:',F10.4)
   END IF
   IF(LLOC.LT.200) GO TO 25
   !
   !8C-----PRINT A MESSAGE SHOWING OPTIONS.
   IF(IXSEC.NE.0) WRITE(IOUT,61)
61 FORMAT(1X,'CROSS SECTION OPTION IS SPECIFIED')
   IF(ICHFLG.NE.0) WRITE(IOUT,62)
62 FORMAT(1X,'CALCULATE FLOW BETWEEN ADJACENT CONSTANT-HEAD CELLS')
   !
   !8D-----INITIALIZE TOTAL ELAPSED TIME COUNTER STORAGE ARRAY COUNTER
   !8D-----AND CALCULATE NUMBER OF CELLS.
   TOTIM=0.
   !
   !8E-----READ BOUNDARY ARRAY(IBOUND).
   IF(IXSEC.EQ.0) THEN
      DO 280 K=1,NLAY
         KK=K
         CALL U2DINT(IBOUND(:,:,KK),ANAME(1),NROW,NCOL,KK,INBAS,IOUT)
280   CONTINUE
   ELSE
      CALL U2DINT(IBOUND(:,:,1),ANAME(1),NLAY,NCOL,-1,INBAS,IOUT)
   END IF
   !
   !8F-----READ AND PRINT HEAD VALUE TO BE PRINTED FOR NO-FLOW CELLS.
   IF(IFREFM.EQ.0) THEN
      READ(INBAS,'(F10.0)') HNOFLO
   ELSE
      READ(INBAS,*) HNOFLO
   END IF
   HNF=HNOFLO
   WRITE(IOUT,3) HNOFLO
3  FORMAT(1X,/1X,'AQUIFER HEAD WILL BE SET TO ',1PG12.5,&
   &' AT ALL NO-FLOW NODES (IBOUND=0).')
   !
   !8G-----READ INITIAL HEADS.
   IF(IXSEC.EQ.0) THEN
      DO 300 K=1,NLAY
         KK=K
         CALL U2DREL(STRT(:,:,KK),ANAME(2),NROW,NCOL,KK,INBAS,IOUT)
300   CONTINUE
   ELSE
      CALL U2DREL(STRT(:,:,1),ANAME(2),NLAY,NCOL,-1,INBAS,IOUT)
   END IF
   !
   !9------COPY INITIAL HEADS FROM STRT TO HNEW.
   DO 400 K=1,NLAY
      DO 400 I=1,NROW
         DO 400 J=1,NCOL
            HNEW(J,I,K)=STRT(J,I,K)
            IF(IBOUND(J,I,K).EQ.0) HNEW(J,I,K)=HNF
400 CONTINUE
   !
   !10-----SET UP OUTPUT CONTROL.
   CALL SGWF2BAS7I(NLAY,IUNIT(IUOC),IOUT,IFREFM,NIUNIT)
   !
   !11-----INITIALIZE VOLUMETRIC BUDGET ACCUMULATORS TO ZERO.
590 ZERO=0.
   DO 600 I=1,NIUNIT
      DO 600 J=1,4
         VBVL(J,I)=ZERO
600 CONTINUE
   !
   !12-----Allocate and read Zone and Multiplier arrays
   CALL SGWF2BAS7ARMZ(IUNIT(IUZON),IUNIT(IUMLT))
   !
   !13-----READ PARAMETER VALUES FILE.
   CALL SGWF2BAS7ARPVAL(IUPVAL)
   !
   !14-----SAVE POINTERS TO DATA AND RETURN.
   CALL SGWF2BAS7PSV(IGRID)
   RETURN
END
SUBROUTINE GWF2BAS7ST(KPER,IGRID)
   !     ******************************************************************
   !     SETUP TIME VARIABLES FOR NEW TIME PERIOD
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:IOUT,PERLEN,NSTP,TSMULT
   USE GWFBASMODULE,ONLY:DELT,PERTIM
   !     ------------------------------------------------------------------
   CALL SGWF2BAS7PNT(IGRID)
   !
   !1------WRITE STRESS PERIOD INFORMATION
   WRITE (IOUT,1) KPER,PERLEN(KPER),NSTP(KPER),TSMULT(KPER)
1  FORMAT('1',/28X,'STRESS PERIOD NO. ',I4,', LENGTH =',G15.7,/&
   &28X,47('-'),//&
   &30X,'NUMBER OF TIME STEPS =',I6,//&
   &31X,'MULTIPLIER FOR DELT =',F10.3)
   !
   !2------CALCULATE THE LENGTH OF THE FIRST TIME STEP.
   !
   !2A-----ASSUME TIME STEP MULTIPLIER IS EQUAL TO ONE.
   DELT=PERLEN(KPER)/FLOAT(NSTP(KPER))
   !
   !2B-----IF TIME STEP MULTIPLIER IS NOT ONE THEN CALCULATE FIRST
   !2B-----TERM OF GEOMETRIC PROGRESSION.
   ONE=1.
   IF(TSMULT(KPER).NE.ONE)&
   &DELT=PERLEN(KPER)*(ONE-TSMULT(KPER))/&
   &(ONE-TSMULT(KPER)**NSTP(KPER))
   !
   !3------PRINT THE LENGTH OF THE FIRST TIME STEP.
   WRITE (IOUT,9) DELT
9  FORMAT(1X,/28X,'INITIAL TIME STEP SIZE =',G15.7)
   !
   !4------INITIALIZE PERTIM (ELAPSED TIME WITHIN STRESS PERIOD).
   PERTIM=0.
   !
   !5------CHECK THAT ALL PARAMETERS IN PARAMETER VALUE FILE HAVE BEEN DEFINED.
   IF(KPER.GT.1) CALL SGWF2BAS7STPVAL()
   !
   !6------RETURN
   RETURN
END
SUBROUTINE GWF2BAS7AD(KPER,KSTP,IGRID)
   !     ******************************************************************
   !     ADVANCE TO NEXT TIME STEP
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:NCOL,NROW,NLAY,TSMULT,HNEW,HOLD
   USE GWFBASMODULE,ONLY:DELT,TOTIM,PERTIM
   !     ------------------------------------------------------------------
   CALL SGWF2BAS7PNT(IGRID)
   !
   !1------IF NOT FIRST TIME STEP THEN CALCULATE TIME STEP LENGTH.
   IF(KSTP.NE.1) DELT=TSMULT(KPER)*DELT
   !
   !2------ACCUMULATE ELAPSED TIME IN SIMULATION(TOTIM) AND IN THIS
   !2------STRESS PERIOD(PERTIM).
   TOTIM=TOTIM+DELT
   PERTIM=PERTIM+DELT
   !
   !3------COPY HNEW TO HOLD.
   DO 10 K=1,NLAY
      DO 10 I=1,NROW
         DO 10 J=1,NCOL
10 HOLD(J,I,K)=HNEW(J,I,K)
   !
   !4------RETURN
   RETURN
END
SUBROUTINE GWF2BAS7FM(IGRID)
   !     ******************************************************************
   !     SET HCOF=RHS=0.
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,ONLY:HCOF,RHS
   !     ------------------------------------------------------------------
   CALL SGWF2BAS7PNT(IGRID)
   !
   !1------FOR EACH CELL INITIALIZE HCOF AND RHS ACCUMULATORS.
   ZERO=0.
   HCOF=ZERO
   RHS=ZERO
   !
   !2------RETURN
   RETURN
END
SUBROUTINE GWF2BAS7OC(KSTP,KPER,ICNVG,INOC,IGRID)
   !     ******************************************************************
   !     OUTPUT CONTROLLER FOR HEAD, DRAWDOWN, AND BUDGET
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:IOUT,NLAY,NSTP,IXSEC,IFREFM
   USE GWFBASMODULE,ONLY:IHDDFL,IBUDFL,ICBCFL,IPEROC,ITSOC,IBDOPT,&
   &IOFLG
   !
   !     ------------------------------------------------------------------
   CALL SGWF2BAS7PNT(IGRID)
   !
   !1------TEST UNIT NUMBER (INOC (INOC=IUNIT(12))) TO SEE IF
   !1------OUTPUT CONTROL IS ACTIVE.  IF NOT, SET DEFAULTS AND RETURN.
   IF(INOC.LE.0) THEN
      IHDDFL=0
      IF(ICNVG.EQ.0 .OR. KSTP.EQ.NSTP(KPER))IHDDFL=1
      IBUDFL=0
      IF(ICNVG.EQ.0 .OR. KSTP.EQ.NSTP(KPER))IBUDFL=1
      ICBCFL=0
      GO TO 1000
   END IF
   !
   !2------OUTPUT CONTROL IS ACTIVE.  IF IPEROC >= 0, READ OUTPUT FLAGS
   !2------USING ALPHABETIC INPUT STRUCTURE.
   IF(IPEROC.GE.0) THEN
      CALL SGWF2BAS7N(KPER,KSTP,INOC,IOUT,NLAY)
      GO TO 600
   END IF
   !
   !3------READ AND PRINT OUTPUT FLAGS AND CODE FOR DEFINING IOFLG USING
   !3------THE ORIGINAL NUMERIC INPUT STRUCTURE.
   IF(IFREFM.EQ.0) THEN
      READ(INOC,'(4I10)') INCODE,IHDDFL,IBUDFL,ICBCFL
   ELSE
      READ(INOC,*) INCODE,IHDDFL,IBUDFL,ICBCFL
   END IF
   WRITE(IOUT,3) IHDDFL,IBUDFL,ICBCFL
3  FORMAT(1X,/1X,'HEAD/DRAWDOWN PRINTOUT FLAG =',I2,&
   &5X,'TOTAL BUDGET PRINTOUT FLAG =',I2,&
   &/1X,'CELL-BY-CELL FLOW TERM FLAG =',I2)
   IF(ICBCFL.NE.0) ICBCFL=IBDOPT
   !
   !4------DECODE INCODE TO DETERMINE HOW TO SET FLAGS IN IOFLG.
   IF(INCODE.LT.0) THEN
   !
   !5------INCODE <0, USE IOFLG FROM LAST TIME STEP.
      WRITE(IOUT,101)
101   FORMAT(1X,'REUSING PREVIOUS VALUES OF IOFLG')
   ELSE IF(INCODE.EQ.0) THEN
   !
   !6------INCODE=0, READ IOFLG FOR LAYER 1 AND ASSIGN SAME TO ALL LAYERS
      IF(IFREFM.EQ.0) THEN
         READ(INOC,'(4I10)') (IOFLG(1,M),M=1,4)
      ELSE
         READ(INOC,*) (IOFLG(1,M),M=1,4)
      END IF
      IOFLG(1,5)=0
      DO 210 K=1,NLAY
         IOFLG(K,1)=IOFLG(1,1)
         IOFLG(K,2)=IOFLG(1,2)
         IOFLG(K,3)=IOFLG(1,3)
         IOFLG(K,4)=IOFLG(1,4)
         IOFLG(K,5)=IOFLG(1,5)
210   CONTINUE
      WRITE(IOUT,211) (IOFLG(1,M),M=1,4)
211   FORMAT(1X,/1X,'OUTPUT FLAGS FOR ALL LAYERS ARE THE SAME:'/&
      &1X,'  HEAD    DRAWDOWN  HEAD  DRAWDOWN'/&
      &1X,'PRINTOUT  PRINTOUT  SAVE    SAVE'/&
      &1X,34('-')/1X,I5,I10,I8,I8)
   ELSE
   !
   !7------INCODE>0, READ IOFLG IN ENTIRETY -- IF CROSS SECTION, READ ONLY
   !7------ONE VALUE.
      IF(IXSEC.EQ.0) THEN
         DO 301 K=1,NLAY
            IF(IFREFM.EQ.0) THEN
               READ(INOC,'(4I10)') (IOFLG(K,M),M=1,4)
            ELSE
               READ(INOC,*) (IOFLG(K,M),M=1,4)
            END IF
            IOFLG(K,5)=0
301      CONTINUE
         WRITE(IOUT,302) 'OUTPUT FLAGS FOR EACH LAYER:','LAYER'
302      FORMAT(1X,/1X,A,/&
         &1X,'         HEAD    DRAWDOWN  HEAD  DRAWDOWN'/&
         &1X,A,'  PRINTOUT  PRINTOUT  SAVE    SAVE'/&
         &1X,41('-'))
         WRITE(IOUT,303) (K,(IOFLG(K,M),M=1,4),K=1,NLAY)
303      FORMAT(1X,I4,I8,I10,I8,I8)
      ELSE
         IF(IFREFM.EQ.0) THEN
            READ(INOC,'(4I10)') (IOFLG(1,M),M=1,4)
         ELSE
            READ(INOC,*) (IOFLG(1,M),M=1,4)
         END IF
         WRITE(IOUT,302) 'OUTPUT FLAGS FOR CROSS SECTION:','     '
         WRITE(IOUT,304) (IOFLG(1,M),M=1,4)
304      FORMAT(1X,I12,I10,I8,I8)
      END IF
   END IF
   !
   !8------THE LAST STEP IN A STRESS PERIOD AND STEPS WHERE ITERATIVE
   !8------PROCEDURE FAILED TO CONVERGE GET A VOLUMETRIC BUDGET.
600 IF(ICNVG.EQ.0 .OR. KSTP.EQ.NSTP(KPER)) IBUDFL=1
   !
   !9------RETURN
1000 RETURN
   !
END
SUBROUTINE GWF2BAS7OT(KSTP,KPER,ICNVG,ISA,IGRID,BUDPERC)
   !     ******************************************************************
   !     OUTPUT TIME, VOLUMETRIC BUDGET, HEAD, AND DRAWDOWN
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:ITMUNI,IOUT,NCOL,NROW,NLAY,HNEW,STRT,DDREF
   USE GWFBASMODULE,ONLY:DELT,PERTIM,TOTIM,IHDDFL,IBUDFL,&
   &MSUM,VBVL,VBNM,IDDREF
   !     ------------------------------------------------------------------
   !
   CALL SGWF2BAS7PNT(IGRID)
   !
   !1------CLEAR PRINTOUT FLAG (IPFLG)
   IPFLG=0
   BUDPERC=1.E30
   !
   !
   IF(ISA.EQ.0) THEN
      WRITE(IOUT,9) KSTP,KPER
9     FORMAT(1X,/9X,'NO FLOW EQUATION TO SOLVE IN TIME STEP',I5,&
      &' OF STRESS PERIOD',I3,/1X,'ALL HEADS ARE 0.0')
      IPFLG=1
   END IF
   !
   !2------IF ITERATIVE PROCEDURE FAILED TO CONVERGE PRINT MESSAGE
   IF(ICNVG.EQ.0) THEN
      WRITE(IOUT,17) KSTP,KPER
17    FORMAT(1X,/9X,&
      &'****FAILED TO MEET SOLVER CONVERGENCE CRITERIA IN TIME STEP',&
      &I5,' OF STRESS PERIOD ',I4,'****')
      IPFLG=1
   END IF
   !
   !3------IF HEAD AND DRAWDOWN FLAG (IHDDFL) IS SET WRITE HEAD,
   !3------DRAWDOWN, AND IBOUND IN ACCORDANCE WITH FLAGS IN IOFLG.
   IF(IHDDFL.EQ.0) GO TO 100
   !
   CALL SGWF2BAS7H(KSTP,KPER,IPFLG,ISA)
   CALL SGWF2BAS7D(KSTP,KPER,IPFLG,ISA)
   CALL SGWF2BAS7IB(KSTP,KPER)
   !
100 CONTINUE

   !4------PRINT TOTAL BUDGET IF REQUESTED
   IF(IBUDFL.EQ.0) GO TO 120
   CALL SGWF2BAS7V(MSUM,VBNM,VBVL,KSTP,KPER,IOUT,BUDPERC)
   IPFLG=1
   !
   !5------END PRINTOUT WITH TIME SUMMARY AND FORM FEED IF ANY PRINTOUT
   !5------WILL BE PRODUCED.
120 IF(IDDREF.NE.0) THEN
      IF(ASSOCIATED(DDREF,STRT)) THEN
         ALLOCATE(DDREF(NCOL,NROW,NLAY))
         CALL SGWF2BAS7PSV(IGRID)
      END IF
   ! RGN 10-7-2015 made explcit do for setting DDREF=HNEW
      DO il = 1, NLAY
         DO ir = 1, NROW
            DO ic = 1, NCOL
               DDREF(ic,ir,il)=HNEW(ic,ir,il)
            END DO
         END DO
      END DO
   !
      WRITE(IOUT,99)
99    FORMAT(1X,'Drawdown Reference has been reset to the',&
      &' end of this time step')
      IDDREF=0
   END IF
   IF(IPFLG.EQ.0) RETURN
   CALL SGWF2BAS7T(KSTP,KPER,DELT,PERTIM,TOTIM,ITMUNI,IOUT)
   WRITE(IOUT,101)
101 FORMAT('1')
   !
   !6------RETURN
   RETURN
END
SUBROUTINE SGWF2BAS7ARDIS(IUDIS,IOUT)
   !     *****************************************************************
   !     ALLOCATE AND READ DIS DATA
   !     *****************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,     ONLY:NCOL,NROW,NLAY,NPER,NBOTM,NCNFBD,ITMUNI,&
   &LENUNI,IUNIT,LBOTM,LAYCBD,ITRSS,&
   &PERLEN,NSTP,TSMULT,ISSFLG,DELR,DELC,BOTM
   !
   CHARACTER*200 LINE
   CHARACTER*24 ANAME(5)
   DATA ANAME(1) /'                    DELR'/
   DATA ANAME(2) /'                    DELC'/
   DATA ANAME(3) /'TOP ELEVATION OF LAYER 1'/
   DATA ANAME(4) /'  MODEL LAYER BOTTOM EL.'/
   DATA ANAME(5) /'BOT. EL. OF QUASI-3D BED'/
   !     ------------------------------------------------------------------
   !
   !1------Check for existence of discretization file
   INDIS=IUNIT(IUDIS)
   IF(INDIS.LE.0) THEN
      WRITE(IOUT,*) ' DIS file must be specified for MODFLOW to run'
      CALL USTOP(' ')
   END IF
   WRITE(IOUT,11) INDIS
11 FORMAT(1X,/1X,'DISCRETIZATION INPUT DATA READ FROM UNIT ',I4)
   !
   !
   !2------Read comments and the first line following the comments.
   CALL URDCOM(INDIS,IOUT,LINE)
   !
   !3------Get the number of layers, rows, columns, stress periods,
   !3------ITMUNI, and LENUNI from the line.
   LLOC=1
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NLAY,R,IOUT,INDIS)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NROW,R,IOUT,INDIS)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NCOL,R,IOUT,INDIS)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPER,R,IOUT,INDIS)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ITMUNI,R,IOUT,INDIS)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,LENUNI,R,IOUT,INDIS)
   !
   !4------PRINT # OF LAYERS, ROWS, COLUMNS AND STRESS PERIODS.
   WRITE(IOUT,15) NLAY,NROW,NCOL
15 FORMAT(1X,I4,' LAYERS',I10,' ROWS',I10,' COLUMNS')
   WRITE(IOUT,20) NPER
20 FORMAT(1X,I4,' STRESS PERIOD(S) IN SIMULATION')
   !
   !5------SELECT AND PRINT A MESSAGE SHOWING TIME UNIT.
   IF(ITMUNI.LT.0 .OR. ITMUNI.GT.5) ITMUNI=0
   IF(ITMUNI.EQ.0) THEN
      WRITE(IOUT,30)
30    FORMAT(1X,'MODEL TIME UNIT IS UNDEFINED')
   ELSE IF(ITMUNI.EQ.1) THEN
      WRITE(IOUT,40)
40    FORMAT(1X,'MODEL TIME UNIT IS SECONDS')
   ELSE IF(ITMUNI.EQ.2) THEN
      WRITE(IOUT,50)
50    FORMAT(1X,'MODEL TIME UNIT IS MINUTES')
   ELSE IF(ITMUNI.EQ.3) THEN
      WRITE(IOUT,60)
60    FORMAT(1X,'MODEL TIME UNIT IS HOURS')
   ELSE IF(ITMUNI.EQ.4) THEN
      WRITE(IOUT,70)
70    FORMAT(1X,'MODEL TIME UNIT IS DAYS')
   ELSE
      WRITE(IOUT,80)
80    FORMAT(1X,'MODEL TIME UNIT IS YEARS')
   END IF
   !
   !6------SELECT AND PRINT A MESSAGE SHOWING LENGTH UNIT.
   IF(LENUNI.LT.0 .OR. LENUNI.GT.3) LENUNI=0
   IF(LENUNI.EQ.0) THEN
      WRITE(IOUT,90)
90    FORMAT(1X,'MODEL LENGTH UNIT IS UNDEFINED')
   ELSE IF(LENUNI.EQ.1) THEN
      WRITE(IOUT,91)
91    FORMAT(1X,'MODEL LENGTH UNIT IS FEET')
   ELSE IF(LENUNI.EQ.2) THEN
      WRITE(IOUT,93)
93    FORMAT(1X,'MODEL LENGTH UNIT IS METERS')
   ELSE IF(LENUNI.EQ.3) THEN
      WRITE(IOUT,95)
95    FORMAT(1X,'MODEL LENGTH UNIT IS CENTIMETERS')
   END IF
   !
   !7------ALLOCATE LAYER FLAGS.
   ALLOCATE(LBOTM(NLAY))
   ALLOCATE(LAYCBD(NLAY))
   !
   !8------Read confining bed information
   READ(INDIS,*) (LAYCBD(K),K=1,NLAY)
   LAYCBD(NLAY)=0
   WRITE(IOUT,*) ' Confining bed flag for each layer:'
   WRITE(IOUT,'(20I4)') (LAYCBD(K),K=1,NLAY)
   !
   !9------Count confining beds, setup the pointer to each layer's
   !9------bottom array (LBOTM), and setup LAYCBD to be the confining
   !9------bed number for each layer.
   NCNFBD=0
   DO 100 K=1,NLAY
      LBOTM(K)=K+NCNFBD
      IF(LAYCBD(K).NE.0) THEN
         NCNFBD=NCNFBD+1
         LAYCBD(K)=NCNFBD
      END IF
100 CONTINUE
   NBOTM=NLAY+NCNFBD
   !
   !10-----Allocate space for discretization arrays
   !10-----Note that NBOTM+1 arrays are allocated for BOTM
   !10-----because BOTM(J,I,0) contains the top elevation of layer 1.
   ALLOCATE (DELR(NCOL))
   ALLOCATE (DELC(NROW))
   ALLOCATE (BOTM(NCOL,NROW,0:NBOTM))
   ALLOCATE (PERLEN(NPER),NSTP(NPER),TSMULT(NPER),ISSFLG(NPER))
   !
   !11-----Read the DELR and DELC arrays.
   CALL U1DREL(DELR,ANAME(1),NCOL,INDIS,IOUT)
   CALL U1DREL(DELC,ANAME(2),NROW,INDIS,IOUT)
   !
   !12-----Read the top elevation of layer 1.
   CALL U2DREL(BOTM(:,:,0),ANAME(3),NROW,NCOL,0,INDIS,IOUT)
   !
   !13-----Read the bottom elevations.
   DO 120 K=1,NLAY
      KK=K
      CALL U2DREL(BOTM(:,:,LBOTM(K)),ANAME(4),NROW,NCOL,KK,INDIS,IOUT)
      IF(LAYCBD(K).NE.0) CALL U2DREL(BOTM(:,:,LBOTM(K)+1),ANAME(5),&
      &NROW,NCOL,KK,INDIS,IOUT)
120 CONTINUE
   !
   !14-----READ AND WRITE LENGTH OF STRESS PERIOD, NUMBER OF TIME STEPS,
   !14-----TIME STEP MULTIPLIER, AND STEADY-STATE FLAG..
   WRITE(IOUT,161)
161 FORMAT(1X,//1X,'STRESS PERIOD     LENGTH       TIME STEPS',&
   &'     MULTIPLIER FOR DELT    SS FLAG',/1X,76('-'))
   ISS=0
   ITR=0
   DO 200 N=1,NPER
      READ(INDIS,'(A)') LINE
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,I,PERLEN(N),IOUT,INDIS)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NSTP(N),R,IOUT,INDIS)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,I,TSMULT(N),IOUT,INDIS)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,I,R,IOUT,INDIS)
      IF (LINE(ISTART:ISTOP).EQ.'TR') THEN
         ISSFLG(N)=0
         ITR=1
      ELSE IF (LINE(ISTART:ISTOP).EQ.'SS') THEN
         ISSFLG(N)=1
         ISS=1
      ELSE
         WRITE(IOUT,162)
162      FORMAT(' SSFLAG MUST BE EITHER "SS" OR "TR"',&
         &' -- STOP EXECUTION (SGWF2BAS7ARDIS)')
         CALL USTOP(' ')
      END IF
      WRITE (IOUT,163) N,PERLEN(N),NSTP(N),TSMULT(N),LINE(ISTART:ISTOP)
163   FORMAT(1X,I8,1PG21.7,I7,0PF25.3,A11)
   !
   !15-----STOP IF NSTP LE 0, PERLEN EQ 0 FOR TRANSIENT STRESS PERIODS,
   !15-----TSMULT LE 0, OR PERLEN LT 0..
      IF(NSTP(N).LE.0) THEN
         WRITE(IOUT,164)
164      FORMAT(1X,/1X,&
         &'THERE MUST BE AT LEAST ONE TIME STEP IN EVERY STRESS PERIOD')
         CALL USTOP(' ')
      END IF
      ZERO=0.
      IF(PERLEN(N).EQ.ZERO .AND. ISSFLG(N).EQ.0) THEN
         WRITE(IOUT,165)
165      FORMAT(1X,/1X,&
         &'PERLEN MUST NOT BE 0.0 FOR TRANSIENT STRESS PERIODS')
         CALL USTOP(' ')
      END IF
      IF(TSMULT(N).LE.ZERO) THEN
         WRITE(IOUT,170)
170      FORMAT(1X,/1X,'TSMULT MUST BE GREATER THAN 0.0')
         CALL USTOP(' ')
      END IF
      IF(PERLEN(N).LT.ZERO) THEN
         WRITE(IOUT,175)
175      FORMAT(1X,/1X,&
         &'PERLEN CANNOT BE LESS THAN 0.0 FOR ANY STRESS PERIOD')
         CALL USTOP(' ')
      END IF
200 CONTINUE
   !
   !16-----Assign ITRSS.
   IF(ISS.EQ.0 .AND. ITR.NE.0) THEN
      ITRSS=1
      WRITE(IOUT,270)
270   FORMAT(/,1X,'TRANSIENT SIMULATION')
   ELSE IF(ISS.NE.0 .AND. ITR.EQ.0) THEN
      ITRSS=0
      WRITE(IOUT,275)
275   FORMAT(/,1X,'STEADY-STATE SIMULATION')
   ELSE
      ITRSS=-1
      WRITE(IOUT,280)
280   FORMAT(/,1X,'COMBINED STEADY-STATE AND TRANSIENT SIMULATION')
   END IF
   !
   !17-----RETURN.
   RETURN
END
SUBROUTINE SGWF2BAS7D(KSTP,KPER,IPFLG,ISA)
   !     ******************************************************************
   !     CALCULATE, PRINT, AND SAVE DRAWDOWNS
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:NCOL,NROW,NLAY,IXSEC,HNEW,BUFF,IBOUND,&
   &DDREF,IOUT
   USE GWFBASMODULE,ONLY:PERTIM,TOTIM,IDDNFM,IDDNUN,LBDDSV,&
   &CDDNFM,IOFLG
   !
   CHARACTER*16 TEXT
   DOUBLE PRECISION SSTRT
   !
   DATA TEXT /'        DRAWDOWN'/
   !     ------------------------------------------------------------------
   !
   !1------FOR EACH LAYER CALCULATE DRAWDOWN IF PRINT OR SAVE IS REQUESTED.
   DO 59 K=1,NLAY
   !
   !2------IS DRAWDOWN NEEDED FOR THIS LAYER?
      KL=K
      IF(IXSEC.NE.0) KL=1
      IF(IOFLG(KL,2).EQ.0 .AND. IOFLG(KL,4).EQ.0) GO TO 59
   !
   !4------CALCULATE DRAWDOWN FOR THE LAYER.
      DO 58 I=1,NROW
         DO 58 J=1,NCOL
            BUFF(J,I,K)=HNEW(J,I,K)
            SSTRT=DDREF(J,I,K)
            IF(IBOUND(J,I,K).NE.0) BUFF(J,I,K)=SSTRT-HNEW(J,I,K)
58    CONTINUE
59 CONTINUE
   !
   !5------FOR EACH LAYER: DETERMINE IF DRAWDOWN SHOULD BE PRINTED.
   !5------IF SO THEN CALL ULAPRS OR ULAPRW TO PRINT DRAWDOWN.
   IF(ISA.NE.0) THEN
      IF(IXSEC.EQ.0) THEN
         DO 69 K=1,NLAY
            KK=K
            IF(IOFLG(K,2).EQ.0) GO TO 69
            IF(IDDNFM.LT.0) CALL ULAPRS(BUFF(:,:,K),TEXT,KSTP,KPER,&
            &NCOL,NROW,KK,-IDDNFM,IOUT)
            IF(IDDNFM.GE.0) CALL ULAPRW(BUFF(:,:,K),TEXT,KSTP,KPER,&
            &NCOL,NROW,KK,IDDNFM,IOUT)
            IPFLG=1
69       CONTINUE
   !
   !5A-----PRINT DRAWDOWN FOR CROSS SECTION.
      ELSE
         IF(IOFLG(1,2).NE.0) THEN
            IF(IDDNFM.LT.0) CALL ULAPRS(BUFF,TEXT,KSTP,KPER,&
            &NCOL,NLAY,-1,-IDDNFM,IOUT)
            IF(IDDNFM.GE.0) CALL ULAPRW(BUFF,TEXT,KSTP,KPER,&
            &NCOL,NLAY,-1,IDDNFM,IOUT)
            IPFLG=1
         END IF
      END IF
   END IF
   !
   !6------FOR EACH LAYER: DETERMINE IF DRAWDOWN SHOULD BE SAVED.
   !6------IF SO THEN CALL A ULASAV OR ULASV2 TO RECORD DRAWDOWN.
   IFIRST=1
   IF(IDDNUN.LE.0) GO TO 80
   IF(IXSEC.EQ.0) THEN
      DO 79 K=1,NLAY
         KK=K
         IF(IOFLG(K,4).EQ.0) GO TO 79
         IF(IFIRST.EQ.1) WRITE(IOUT,74) IDDNUN,KSTP,KPER
74       FORMAT(1X,/1X,'DRAWDOWN WILL BE SAVED ON UNIT ',I4,&
         &' AT END OF TIME STEP',I5,', STRESS PERIOD ',I4)
         IFIRST=0
         IF(CDDNFM.EQ.' ') THEN
            CALL ULASAV(BUFF(:,:,K),TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NROW,KK,IDDNUN)
         ELSE
            CALL ULASV2(BUFF(:,:,K),TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NROW,KK,IDDNUN,CDDNFM,LBDDSV,IBOUND(:,:,K))
         END IF
79    CONTINUE
   !
   !6A-----SAVE DRAWDOWN FOR CROSS SECTION.
   ELSE
      IF(IOFLG(1,4).NE.0) THEN
         WRITE(IOUT,74) IDDNUN,KSTP,KPER
         IF(CDDNFM.EQ.' ') THEN
            CALL ULASAV(BUFF,TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NLAY,-1,IDDNUN)
         ELSE
            CALL ULASV2(BUFF,TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NLAY,-1,IDDNUN,CDDNFM,LBDDSV,IBOUND)
         END IF
      END IF
   END IF
   !
   !7------RETURN.
80 RETURN
END
SUBROUTINE SGWF2BAS7H(KSTP,KPER,IPFLG,ISA)
   !     ******************************************************************
   !     PRINT AND RECORD HEADS
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:NCOL,NROW,NLAY,IXSEC,HNEW,BUFF,&
   &IBOUND,IOUT
   USE GWFBASMODULE,ONLY:PERTIM,TOTIM,IHEDFM,IHEDUN,LBHDSV,&
   &CHEDFM,IOFLG
   !
   CHARACTER*16 TEXT
   DATA TEXT /'            HEAD'/
   !     ------------------------------------------------------------------
   !
   !1------FOR EACH LAYER MOVE HNEW TO BUFF IF PRINT OR SAVE IS REQUESTED.
   DO 59 K=1,NLAY
   !
   !2------IS HEAD NEEDED FOR THIS LAYER?
      KL=K
      IF(IXSEC.NE.0) KL=1
      IF(IOFLG(KL,1).EQ.0 .AND. IOFLG(KL,3).EQ.0) GO TO 59
   !
   !3------MOVE HNEW TO BUFF FOR THE LAYER.
      DO 58 I=1,NROW
         DO 58 J=1,NCOL
            BUFF(J,I,K)=HNEW(J,I,K)
58    CONTINUE
59 CONTINUE
   !
   !4------FOR EACH LAYER: DETERMINE IF HEAD SHOULD BE PRINTED.
   !4------IF SO THEN CALL ULAPRS OR ULAPRW TO PRINT HEAD.
   IF(ISA.NE.0) THEN
      IF(IXSEC.EQ.0) THEN
         DO 69 K=1,NLAY
            KK=K
            IF(IOFLG(K,1).EQ.0) GO TO 69
            IF(IHEDFM.LT.0) CALL ULAPRS(BUFF(:,:,K),TEXT,KSTP,KPER,&
            &NCOL,NROW,KK,-IHEDFM,IOUT)
            IF(IHEDFM.GE.0) CALL ULAPRW(BUFF(:,:,K),TEXT,KSTP,KPER,&
            &NCOL,NROW,KK,IHEDFM,IOUT)
            IPFLG=1
69       CONTINUE
   !
   !4A-----PRINT HEAD FOR CROSS SECTION.
      ELSE
         IF(IOFLG(1,1).NE.0) THEN
            IF(IHEDFM.LT.0) CALL ULAPRS(BUFF,TEXT,KSTP,KPER,&
            &NCOL,NLAY,-1,-IHEDFM,IOUT)
            IF(IHEDFM.GE.0) CALL ULAPRW(BUFF,TEXT,KSTP,KPER,&
            &NCOL,NLAY,-1,IHEDFM,IOUT)
            IPFLG=1
         END IF
      END IF
   END IF
   !
   !5------FOR EACH LAYER: DETERMINE IF HEAD SHOULD BE SAVED ON DISK.
   !5------IF SO THEN CALL ULASAV OR ULASV2 TO SAVE HEAD.
   IFIRST=1
   IF(IHEDUN.LE.0) GO TO 80
   IF(IXSEC.EQ.0) THEN
      DO 79 K=1,NLAY
         KK=K
         IF(IOFLG(K,3).EQ.0) GO TO 79
         IF(IFIRST.EQ.1) WRITE(IOUT,74) IHEDUN,KSTP,KPER
74       FORMAT(1X,/1X,'HEAD WILL BE SAVED ON UNIT ',I4,&
         &' AT END OF TIME STEP',I5,', STRESS PERIOD ',I4)
         IFIRST=0
         IF(CHEDFM.EQ.' ') THEN
            CALL ULASAV(BUFF(:,:,K),TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NROW,KK,IHEDUN)
         ELSE
            CALL ULASV2(BUFF(:,:,K),TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NROW,KK,IHEDUN,CHEDFM,LBHDSV,IBOUND(:,:,K))
         END IF
79    CONTINUE
   !
   !5A-----SAVE HEAD FOR CROSS SECTION.
   ELSE
      IF(IOFLG(1,3).NE.0) THEN
         WRITE(IOUT,74) IHEDUN,KSTP,KPER
         IF(CHEDFM.EQ.' ') THEN
            CALL ULASAV(BUFF,TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NLAY,-1,IHEDUN)
         ELSE
            CALL ULASV2(BUFF,TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
            &NLAY,-1,IHEDUN,CHEDFM,LBHDSV,IBOUND)
         END IF
      END IF
   END IF
   !
   !6------RETURN.
80 RETURN
END
SUBROUTINE SGWF2BAS7IB(KSTP,KPER)
   !     ******************************************************************
   !     RECORD IBOUND
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY:NCOL,NROW,NLAY,IXSEC,IBOUND,IOUT
   USE GWFBASMODULE,ONLY:PERTIM,TOTIM,IBOUUN,LBBOSV,CBOUFM,IOFLG
   !
   CHARACTER*16 TEXT
   DATA TEXT /'          IBOUND'/
   !     ------------------------------------------------------------------
   IF(IBOUUN.LE.0) RETURN
   !
   !5------FOR EACH LAYER: SAVE IBOUND WHEN REQUESTED.
   IFIRST=1
   IF(IXSEC.EQ.0) THEN
      DO 79 K=1,NLAY
         KK=K
         IF(IOFLG(K,5).EQ.0) GO TO 79
         IF(IFIRST.EQ.1) WRITE(IOUT,74) IBOUUN,KSTP,KPER
74       FORMAT(1X,/1X,'IBOUND WILL BE SAVED ON UNIT ',I4,&
         &' AT END OF TIME STEP',I5,', STRESS PERIOD ',I4)
         IFIRST=0
         CALL ULASV3(IBOUND(:,:,K),TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
         &NROW,KK,IBOUUN,CBOUFM,LBBOSV)
79    CONTINUE
   !
   !5A-----SAVE IBOUND FOR CROSS SECTION.
   ELSE
      IF(IOFLG(1,5).NE.0) THEN
         WRITE(IOUT,74) IBOUUN,KSTP,KPER
         CALL ULASV3(IBOUND,TEXT,KSTP,KPER,PERTIM,TOTIM,NCOL,&
         &NLAY,-1,IBOUUN,CBOUFM,LBBOSV)
      END IF
   END IF
   !
   !6------RETURN.
   RETURN
END
SUBROUTINE SGWF2BAS7I(NLAY,INOC,IOUT,IFREFM,NIUNIT)
   !     ******************************************************************
   !     SET UP OUTPUT CONTROL.
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GWFBASMODULE, ONLY: IHEDFM,IDDNFM,IHEDUN,IDDNUN,IPEROC,ITSOC,&
   &CHEDFM,CDDNFM,IBDOPT,LBHDSV,LBDDSV,&
   &IBOUUN,LBBOSV,CBOUFM,IAUXSV,IOFLG,&
   &VBVL,VBNM,IDDREF,IDDREFNEW
   CHARACTER*200 LINE
   !     ------------------------------------------------------------------
   !
   !1-----ALLOCATE SPACE FOR IOFLG, VBVL, AND VBNM ARRAYS.
   ALLOCATE (IOFLG(NLAY,5))
   ALLOCATE (VBVL(4,NIUNIT))
   ALLOCATE (VBNM(NIUNIT))
   IDDREF=0
   IDDREFNEW=0
   !
   !1------ASSIGN DEFAULT VALUES.
   CHEDFM=' '
   CDDNFM=' '
   CBOUFM='(20I4)'
   IHEDFM=0
   IDDNFM=0
   IHEDUN=0
   IDDNUN=0
   IBOUUN=0
   IBDOPT=1
   LBHDSV=0
   LBDDSV=0
   LBBOSV=0
   IAUXSV=0
   !
   !2------TEST OUTPUT CONTROL INPUT UNIT TO SEE IF OUTPUT CONTROL IS
   !2------ACTIVE.
   IF(INOC.LE.0) THEN
   !
   !2A-----OUTPUT CONTROL IS INACTIVE. PRINT A MESSAGE LISTING DEFAULTS.
      WRITE(IOUT, 41)
41    FORMAT(1X,/1X,'DEFAULT OUTPUT CONTROL',/1X,&
      &'THE FOLLOWING OUTPUT COMES AT THE END OF EACH STRESS PERIOD:')
      WRITE(IOUT, 42)
42    FORMAT(1X,'TOTAL VOLUMETRIC BUDGET')
      WRITE(IOUT, 43)
43    FORMAT(1X,10X,'HEAD')
   !
   !2B-----SET DEFAULT FLAGS IN IOFLG SO THAT HEAD IS PRINTED FOR
   !2B-----EVERY LAYER.
      DO 80 K=1,NLAY
         IOFLG(K,1)=1
         IOFLG(K,2)=0
         IOFLG(K,3)=0
         IOFLG(K,4)=0
         IOFLG(K,5)=0
80    CONTINUE
      GO TO 1000
   END IF
   !
   !3------OUTPUT CONTROL IS ACTIVE.  READ FIRST RECORD AND DECODE FIRST
   !3------WORD.  MUST USE URWORD IN CASE FIRST WORD IS ALPHABETIC.
   CALL URDCOM(INOC,IOUT,LINE)
   LLOC=1
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
   !
   !4------TEST FOR NUMERIC OUTPUT CONTROL.  FIRST WORD WILL NOT BE
   !4------"PERIOD", "HEAD", "DRAWDOWN", OR "COMPACT".
   IF(LINE(ISTART:ISTOP).NE.'PERIOD' .AND. LINE(ISTART:ISTOP).NE.&
   &'HEAD' .AND. LINE(ISTART:ISTOP).NE.'DRAWDOWN' .AND.&
   &LINE(ISTART:ISTOP).NE.'COMPACT' .AND.&
   &LINE(ISTART:ISTOP).NE.'IBOUND') THEN
   !4A-----NUMERIC OUTPUT CONTROL.  DECODE THE INITIAL RECORD ACCORDINGLY.
      WRITE(IOUT,102)
102   FORMAT(1X,/1X,'OUTPUT CONTROL IS SPECIFIED EVERY TIME STEP')
      IF(IFREFM.EQ.0) THEN
         READ(LINE,'(4I10)') IHEDFM,IDDNFM,IHEDUN,IDDNUN
      ELSE
         LLOC=1
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IHEDFM,R,IOUT,INOC)
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IDDNFM,R,IOUT,INOC)
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IHEDUN,R,IOUT,INOC)
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IDDNUN,R,IOUT,INOC)
      END IF
      WRITE(IOUT,103) IHEDFM,IDDNFM
103   FORMAT(1X,'HEAD PRINT FORMAT CODE IS',I4,&
      &'    DRAWDOWN PRINT FORMAT CODE IS',I4)
      WRITE(IOUT,104) IHEDUN,IDDNUN
104   FORMAT(1X,'HEADS WILL BE SAVED ON UNIT ',I4,&
      &'    DRAWDOWNS WILL BE SAVED ON UNIT ',I4)
      IPEROC=-1
      ITSOC=-1
   ELSE
   !4B-----ALPHABETIC OUTPUT CONTROL.  CALL MODULE TO READ INITIAL RECORDS.
      CALL SGWF2BAS7J(INOC,IOUT,LINE,LLOC,ISTART,ISTOP)
   END IF
   !
   !5------RETURN.
1000 RETURN
END
SUBROUTINE SGWF2BAS7J(INOC,IOUT,LINE,LLOC,ISTART,ISTOP)
   !     ******************************************************************
   !     READ INITIAL ALPHABETIC OUTPUT CONTROL RECORDS.
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GWFBASMODULE, ONLY: IHEDFM,IDDNFM,IHEDUN,IDDNUN,IPEROC,ITSOC,&
   &CHEDFM,CDDNFM,IBDOPT,LBHDSV,LBDDSV,&
   &IBOUUN,LBBOSV,CBOUFM,IAUXSV,IDDREFNEW
   !
   CHARACTER*200 LINE
   !     ------------------------------------------------------------------
   !
   !1------ALPHABETIC OUTPUT CONTROL.  WRITE MESSAGE AND SET INITIAL VALUES
   !1------FOR IPEROC AND ITSOC.
   WRITE(IOUT,91)
91 FORMAT(1X,/1X,'OUTPUT CONTROL IS SPECIFIED ONLY AT TIME STEPS',&
   &' FOR WHICH OUTPUT IS DESIRED')
   IPEROC=9999
   ITSOC=9999
   !
   !2------LOOK FOR ALPHABETIC WORDS:
   !2A-----LOOK FOR "PERIOD", WHICH INDICATES THE END OF INITIAL OUTPUT
   !2A-----CONTROL DATA.  IF FOUND, DECODE THE PERIOD NUMBER AND TIME
   !2A-----STEP NUMBER FOR LATER USE.
100 IF(LINE(ISTART:ISTOP).EQ.'PERIOD') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IPEROC,R,IOUT,INOC)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).NE.'STEP') GO TO 2000
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ITSOC,R,IOUT,INOC)
      WRITE(IOUT,101) IHEDFM,IDDNFM
101   FORMAT(1X,'HEAD PRINT FORMAT CODE IS',I4,&
      &'    DRAWDOWN PRINT FORMAT CODE IS',I4)
      WRITE(IOUT,102) IHEDUN,IDDNUN
102   FORMAT(1X,'HEADS WILL BE SAVED ON UNIT ',I4,&
      &'    DRAWDOWNS WILL BE SAVED ON UNIT ',I4)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'DDREFERENCE') THEN
         IDDREFNEW=1
      ELSE
         IDDREFNEW=0
      END IF
      GO TO 1000
   !
   !2B-----LOOK FOR "HEAD PRINT ..." AND "HEAD SAVE ...".  IF
   !2B-----FOUND, SET APPROPRIATE FLAGS.
   ELSE IF(LINE(ISTART:ISTOP).EQ.'HEAD') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'PRINT') THEN
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).NE.'FORMAT') GO TO 2000
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IHEDFM,R,IOUT,INOC)
      ELSE IF(LINE(ISTART:ISTOP).EQ.'SAVE') THEN
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).EQ.'UNIT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IHEDUN,R,IOUT,&
            &INOC)
         ELSE IF(LINE(ISTART:ISTOP).EQ.'FORMAT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INOC)
            CHEDFM=LINE(ISTART:ISTOP)
            WRITE(IOUT,103) CHEDFM
103         FORMAT(1X,'HEADS WILL BE SAVED WITH FORMAT: ',A)
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
            IF(LINE(ISTART:ISTOP).EQ.'LABEL') THEN
               LBHDSV=1
               WRITE(IOUT,104)
104            FORMAT(1X,'SAVED HEADS WILL BE LABELED')
            END IF
         ELSE
            GO TO 2000
         END IF
      ELSE
         GO TO 2000
      END IF
   !
   !2C-----LOOK FOR "DRAWDOWN PRINT ..." AND "DRAWDOWN SAVE ...".
   !2C-----IF FOUND, SET APPROPRIATE FLAGS
   ELSE IF(LINE(ISTART:ISTOP).EQ.'DRAWDOWN') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'PRINT') THEN
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).NE.'FORMAT') GO TO 2000
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IDDNFM,R,IOUT,INOC)
      ELSE IF(LINE(ISTART:ISTOP).EQ.'SAVE') THEN
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).EQ.'UNIT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IDDNUN,R,IOUT,&
            &INOC)
         ELSE IF(LINE(ISTART:ISTOP).EQ.'FORMAT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INOC)
            CDDNFM=LINE(ISTART:ISTOP)
            WRITE(IOUT,105) CDDNFM
105         FORMAT(1X,'DRAWDOWN WILL BE SAVED WITH FORMAT: ',A)
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
            IF(LINE(ISTART:ISTOP).EQ.'LABEL') THEN
               LBDDSV=1
               WRITE(IOUT,106)
106            FORMAT(1X,'SAVED DRAWDOWN WILL BE LABELED')
            END IF
         ELSE
            GO TO 2000
         END IF
      ELSE
         GO TO 2000
      END IF
   !
   !2D-----LOOK FOR "COMPACT BUDGET FILES" -- "COMPACT" IS SUFFICIENT.
   !2D-----IF FOUND, SET APPROPRIATE FLAG.
   ELSE IF(LINE(ISTART:ISTOP).EQ.'COMPACT') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'BUDGET') THEN
         IBDOPT=2
         WRITE(IOUT,107)
107      FORMAT(1X,&
         &'COMPACT CELL-BY-CELL BUDGET FILES WILL BE WRITTEN')
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).EQ.'AUXILIARY' .OR.&
         &LINE(ISTART:ISTOP).EQ.'AUX') THEN
            IAUXSV=1
            WRITE(IOUT,108)
108         FORMAT(1X,&
            &'AUXILIARY DATA WILL BE SAVED IN CELL-BY-CELL BUDGET FILES')
         END IF
      ELSE
         GO TO 2000
      END IF
   !
   !2E-----LOOK FOR  "IBOUND SAVE ...".  IF FOUND, SET APPROPRIATE FLAGS.
   ELSE IF(LINE(ISTART:ISTOP).EQ.'IBOUND') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'SAVE') THEN
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
         IF(LINE(ISTART:ISTOP).EQ.'UNIT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IBOUUN,R,IOUT,&
            &INOC)
            WRITE(IOUT,111) IBOUUN
111         FORMAT(1X,'IBOUND WILL BE SAVED ON UNIT ',I4)
         ELSE IF(LINE(ISTART:ISTOP).EQ.'FORMAT') THEN
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INOC)
            CBOUFM=LINE(ISTART:ISTOP)
            WRITE(IOUT,112) CBOUFM
112         FORMAT(1X,'IBOUND WILL BE SAVED WITH FORMAT: ',A)
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
            IF(LINE(ISTART:ISTOP).EQ.'LABEL') THEN
               LBBOSV=1
               WRITE(IOUT,109)
109            FORMAT(1X,'SAVED IBOUND WILL BE LABELED')
            END IF
         ELSE
            GO TO 2000
         END IF
      ELSE
         GO TO 2000
      END IF
   !
   !2F-----ERROR IF UNRECOGNIZED WORD.
   ELSE
      GO TO 2000
   END IF
   !
   !3------FINISHED READING A RECORD.  READ NEXT RECORD, IGNORING BLANK
   !3------LINES.  GO BACK AND DECODE IT.
110 READ(INOC,'(A)',END=1000) LINE
   IF(LINE.EQ.' ') GO TO 110
   LLOC=1
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
   GO TO 100
   !
   !4------RETURN.
1000 RETURN
   !
   !5------ERROR DECODING INPUT DATA.
2000 WRITE(IOUT,2001) LINE
2001 FORMAT(1X,/1X,'ERROR READING OUTPUT CONTROL INPUT DATA:'/1X,A80)
   CALL USTOP(' ')
END
SUBROUTINE SGWF2BAS7T(KSTP,KPER,DELT,PERTIM,TOTIM,ITMUNI,IOUT)
   !     ******************************************************************
   !     PRINT SIMULATION TIME
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   !     ------------------------------------------------------------------
   WRITE(IOUT,199) KSTP,KPER
199 FORMAT(1X,///9X,'TIME SUMMARY AT END OF TIME STEP',I5,&
   &' IN STRESS PERIOD ',I4)
   !
   !1------USE TIME UNIT INDICATOR TO GET FACTOR TO CONVERT TO SECONDS.
   ZERO=0.
   CNV=ZERO
   IF(ITMUNI.EQ.1) CNV=1.
   IF(ITMUNI.EQ.2) CNV=60.
   IF(ITMUNI.EQ.3) CNV=3600.
   IF(ITMUNI.EQ.4) CNV=86400.
   IF(ITMUNI.EQ.5) CNV=31557600.
   !
   !2------IF FACTOR=0 THEN TIME UNITS ARE NON-STANDARD.
   IF(CNV.NE.ZERO) GO TO 100
   !
   !2A-----PRINT TIMES IN NON-STANDARD TIME UNITS.
   WRITE(IOUT,301) DELT,PERTIM,TOTIM
301 FORMAT(21X,'     TIME STEP LENGTH =',G15.6/&
   &21X,'   STRESS PERIOD TIME =',G15.6/&
   &21X,'TOTAL SIMULATION TIME =',G15.6)
   !
   !2B-----RETURN
   RETURN
   !
   !3------CALCULATE LENGTH OF TIME STEP & ELAPSED TIMES IN SECONDS.
100 DELSEC=CNV*DELT
   TOTSEC=CNV*TOTIM
   PERSEC=CNV*PERTIM
   !
   !4------CALCULATE TIMES IN MINUTES,HOURS,DAYS AND YEARS.
   SIXTY=60.
   HRDAY=24.
   DAYYR=365.25
   DELMN=DELSEC/SIXTY
   DELHR=DELMN/SIXTY
   DELDY=DELHR/HRDAY
   DELYR=DELDY/DAYYR
   TOTMN=TOTSEC/SIXTY
   TOTHR=TOTMN/SIXTY
   TOTDY=TOTHR/HRDAY
   TOTYR=TOTDY/DAYYR
   PERMN=PERSEC/SIXTY
   PERHR=PERMN/SIXTY
   PERDY=PERHR/HRDAY
   PERYR=PERDY/DAYYR
   !
   !5------PRINT TIME STEP LENGTH AND ELAPSED TIMES IN ALL TIME UNITS.
   WRITE(IOUT,200)
200 FORMAT(19X,' SECONDS     MINUTES      HOURS',7X,&
   &'DAYS        YEARS'/20X,59('-'))
   WRITE (IOUT,201) DELSEC,DELMN,DELHR,DELDY,DELYR
201 FORMAT(1X,'  TIME STEP LENGTH',1P,5G12.5)
   WRITE(IOUT,202) PERSEC,PERMN,PERHR,PERDY,PERYR
202 FORMAT(1X,'STRESS PERIOD TIME',1P,5G12.5)
   WRITE(IOUT,203) TOTSEC,TOTMN,TOTHR,TOTDY,TOTYR
203 FORMAT(1X,'        TOTAL TIME',1P,5G12.5)
   !
   !6------RETURN
   RETURN
END
SUBROUTINE SGWF2BAS7V(MSUM,VBNM,VBVL,KSTP,KPER,IOUT,BUDPERC)
   !     ******************************************************************
   !     PRINT VOLUMETRIC BUDGET
   !     ******************************************************************
   !
   !     SPECIFICATIONS:
   !     ------------------------------------------------------------------
   CHARACTER*20 VBNM(MSUM)
   DIMENSION VBVL(4,MSUM)
   CHARACTER*17 VAL1,VAL2
   !     ------------------------------------------------------------------
   !
   !1------DETERMINE NUMBER OF INDIVIDUAL BUDGET ENTRIES.
   BUDPERC=0.
   MSUM1=MSUM-1
   IF(MSUM1.LE.0) RETURN
   !
   !2------CLEAR RATE AND VOLUME ACCUMULATORS.
   ZERO=0.
   TWO=2.
   HUND=100.
   BIGVL1=9.99999E11
   BIGVL2=9.99999E10
   SMALL=0.1
   TOTRIN=ZERO
   TOTROT=ZERO
   TOTVIN=ZERO
   TOTVOT=ZERO
   !
   !3------ADD RATES AND VOLUMES (IN AND OUT) TO ACCUMULATORS.
   DO 100 L=1,MSUM1
      TOTRIN=TOTRIN+VBVL(3,L)
      TOTROT=TOTROT+VBVL(4,L)
      TOTVIN=TOTVIN+VBVL(1,L)
      TOTVOT=TOTVOT+VBVL(2,L)
100 CONTINUE
   !
   !4------PRINT TIME STEP NUMBER AND STRESS PERIOD NUMBER.
   WRITE(IOUT,260) KSTP,KPER
   WRITE(IOUT,265)
   !
   !5------PRINT INDIVIDUAL INFLOW RATES AND VOLUMES AND THEIR TOTALS.
   DO 200 L=1,MSUM1
      IF(VBVL(1,L).NE.ZERO .AND.&
      &(VBVL(1,L).GE.BIGVL1 .OR. VBVL(1,L).LT.SMALL)) THEN
         WRITE(VAL1,'(1PE17.4)') VBVL(1,L)
      ELSE
         WRITE(VAL1,'(F17.4)') VBVL(1,L)
      END IF
      IF(VBVL(3,L).NE.ZERO .AND.&
      &(VBVL(3,L).GE.BIGVL1 .OR. VBVL(3,L).LT.SMALL)) THEN
         WRITE(VAL2,'(1PE17.4)') VBVL(3,L)
      ELSE
         WRITE(VAL2,'(F17.4)') VBVL(3,L)
      END IF
      WRITE(IOUT,275) VBNM(L),VAL1,VBNM(L),VAL2
200 CONTINUE
   IF(TOTVIN.NE.ZERO .AND.&
   &(TOTVIN.GE.BIGVL1 .OR. TOTVIN.LT.SMALL)) THEN
      WRITE(VAL1,'(1PE17.4)') TOTVIN
   ELSE
      WRITE(VAL1,'(F17.4)') TOTVIN
   END IF
   IF(TOTRIN.NE.ZERO .AND.&
   &(TOTRIN.GE.BIGVL1 .OR. TOTRIN.LT.SMALL)) THEN
      WRITE(VAL2,'(1PE17.4)') TOTRIN
   ELSE
      WRITE(VAL2,'(F17.4)') TOTRIN
   END IF
   WRITE(IOUT,286) VAL1,VAL2
   !
   !6------PRINT INDIVIDUAL OUTFLOW RATES AND VOLUMES AND THEIR TOTALS.
   WRITE(IOUT,287)
   DO 250 L=1,MSUM1
      IF(VBVL(2,L).NE.ZERO .AND.&
      &(VBVL(2,L).GE.BIGVL1 .OR. VBVL(2,L).LT.SMALL)) THEN
         WRITE(VAL1,'(1PE17.4)') VBVL(2,L)
      ELSE
         WRITE(VAL1,'(F17.4)') VBVL(2,L)
      END IF
      IF(VBVL(4,L).NE.ZERO .AND.&
      &(VBVL(4,L).GE.BIGVL1 .OR. VBVL(4,L).LT.SMALL)) THEN
         WRITE(VAL2,'(1PE17.4)') VBVL(4,L)
      ELSE
         WRITE(VAL2,'(F17.4)') VBVL(4,L)
      END IF
      WRITE(IOUT,275) VBNM(L),VAL1,VBNM(L),VAL2
250 CONTINUE
   IF(TOTVOT.NE.ZERO .AND.&
   &(TOTVOT.GE.BIGVL1 .OR. TOTVOT.LT.SMALL)) THEN
      WRITE(VAL1,'(1PE17.4)') TOTVOT
   ELSE
      WRITE(VAL1,'(F17.4)') TOTVOT
   END IF
   IF(TOTROT.NE.ZERO .AND.&
   &(TOTROT.GE.BIGVL1 .OR. TOTROT.LT.SMALL)) THEN
      WRITE(VAL2,'(1PE17.4)') TOTROT
   ELSE
      WRITE(VAL2,'(F17.4)') TOTROT
   END IF
   WRITE(IOUT,298) VAL1,VAL2
   !
   !7------CALCULATE THE DIFFERENCE BETWEEN INFLOW AND OUTFLOW.
   !
   !7A-----CALCULATE DIFFERENCE BETWEEN RATE IN AND RATE OUT.
   DIFFR=TOTRIN-TOTROT
   ADIFFR=ABS(DIFFR)
   !
   !7B-----CALCULATE PERCENT DIFFERENCE BETWEEN RATE IN AND RATE OUT.
   PDIFFR=ZERO
   AVGRAT=(TOTRIN+TOTROT)/TWO
   IF(AVGRAT.NE.ZERO) PDIFFR=HUND*DIFFR/AVGRAT
   BUDPERC=PDIFFR
   !
   !7C-----CALCULATE DIFFERENCE BETWEEN VOLUME IN AND VOLUME OUT.
   DIFFV=TOTVIN-TOTVOT
   ADIFFV=ABS(DIFFV)
   !
   !7D-----GET PERCENT DIFFERENCE BETWEEN VOLUME IN AND VOLUME OUT.
   PDIFFV=ZERO
   AVGVOL=(TOTVIN+TOTVOT)/TWO
   IF(AVGVOL.NE.ZERO) PDIFFV=HUND*DIFFV/AVGVOL
   !
   !8------PRINT DIFFERENCES AND PERCENT DIFFERENCES BETWEEN INPUT
   !8------AND OUTPUT RATES AND VOLUMES.
   IF(ADIFFV.NE.ZERO .AND.&
   &(ADIFFV.GE.BIGVL2 .OR. ADIFFV.LT.SMALL)) THEN
      WRITE(VAL1,'(1PE17.4)') DIFFV
   ELSE
      WRITE(VAL1,'(F17.4)') DIFFV
   END IF
   IF(ADIFFR.NE.ZERO .AND.&
   &(ADIFFR.GE.BIGVL2 .OR. ADIFFR.LT.SMALL)) THEN
      WRITE(VAL2,'(1PE17.4)') DIFFR
   ELSE
      WRITE(VAL2,'(F17.4)') DIFFR
   END IF
   WRITE(IOUT,299) VAL1,VAL2
   WRITE(IOUT,300) PDIFFV,PDIFFR
   !
   !9------RETURN.
   RETURN
   !
   !    ---FORMATS
   !
260 FORMAT('1',/2X,'VOLUMETRIC BUDGET FOR ENTIRE MODEL AT END OF'&
   &,' TIME STEP',I5,', STRESS PERIOD',I4/2X,78('-'))
265 FORMAT(1X,/5X,'CUMULATIVE VOLUMES',6X,'L**3',7X&
   &,'RATES FOR THIS TIME STEP',6X,'L**3/T'/5X,18('-'),17X,24('-')&
   &//11X,'IN:',38X,'IN:'/11X,'---',38X,'---')
275 FORMAT(1X,3X,A20,' =',A17,6X,A20,' =',A17)
286 FORMAT(1X,/16X,'TOTAL IN =',A,18X,'TOTAL IN =',A)
287 FORMAT(1X,/10X,'OUT:',37X,'OUT:'/10X,4('-'),37X,4('-'))
298 FORMAT(1X,/15X,'TOTAL OUT =',A,17X,'TOTAL OUT =',A)
299 FORMAT(1X,/16X,'IN - OUT =',A,18X,'IN - OUT =',A)
300 FORMAT(1X,/5X,'PERCENT DISCREPANCY =',F15.2&
   &,9X,'PERCENT DISCREPANCY =',F15.2,///)
   !
END
SUBROUTINE SGWF2BAS7N(KPER,KSTP,INOC,IOUT,NLAY)
   !     ******************************************************************
   !     SET OUTPUT FLAGS USING ALPHABETIC OUTPUT CONTROL INPUT STRUCTURE
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GWFBASMODULE, ONLY: IOFLG,IHDDFL,IBUDFL,ICBCFL,IPEROC,&
   &ITSOC,IBDOPT,IDDREF,IDDREFNEW
   !
   CHARACTER*200 LINE
   !     ------------------------------------------------------------------
   !
   !1------ERROR IF OUTPUT CONTROL TIME STEP PRECEDES CURRENT SIMULATION
   !1------TIME STEP.
   IF((IPEROC.LT.KPER).OR.(IPEROC.EQ.KPER .AND. ITSOC.LT.KSTP)) THEN
      WRITE(IOUT,5) IPEROC,ITSOC,KPER,KSTP
5     FORMAT(1X,/1X,'OUTPUT CONTROL WAS SPECIFIED FOR A NONEXISTENT',&
      &' TIME STEP',/&
      &1X,'OR OUTPUT CONTROL DATA ARE NOT ENTERED IN ASCENDING ORDER',&
      &/1X,'OUTPUT CONTROL STRESS PERIOD ',I4,'   TIME STEP',I5,/&
      &1X,'MODEL STRESS PERIOD ',I4,'   TIME STEP',I5,/&
      &1X,'APPLYING THE SPECIFIED OUTPUT CONTROL TO THE CURRENT TIME',&
      &' STEP')
      IPEROC=KPER
      ITSOC=KSTP
   END IF
   !
   !2------CLEAR I/O FLAGS.
   IHDDFL=0
   IBUDFL=0
   ICBCFL=0
   DO 10 I=1,5
      DO 10 K=1,NLAY
         IOFLG(K,I)=0
10 CONTINUE
   !
   !3------IF OUTPUT CONTROL TIME STEP DOES NOT MATCH SIMULATION TIME STEP,
   !3------WRITE MESSAGE THAT THERE IS NO OUTPUT CONTROL THIS TIME STEP,
   !3------AND RETURN.
   IF(IPEROC.NE.KPER .OR. ITSOC.NE.KSTP) THEN
      WRITE(IOUT,11) KPER,KSTP
11    FORMAT(1X,/1X,'NO OUTPUT CONTROL FOR STRESS PERIOD ',I4,&
      &'   TIME STEP',I5)
      RETURN
   END IF
   !
   !4------OUTPUT CONTROL TIME STEP MATCHES SIMULATION TIME STEP.
   IDDREF=IDDREFNEW
   WRITE(IOUT,12) IPEROC,ITSOC
12 FORMAT(1X,/1X,'OUTPUT CONTROL FOR STRESS PERIOD ',I4,&
   &'   TIME STEP',I5)
   IF(IDDREFNEW.NE.0) WRITE(IOUT,52)
52 FORMAT(1X,'Drawdown Reference will be reset at the',&
   &' end of this time step')
   !
   !4A-----OUTPUT CONTROL MATCHES SIMULATION TIME.  READ NEXT OUTPUT
   !4A-----RECORD; SKIP ANY BLANK LINES.
50 READ(INOC,'(A)',END=1000) LINE
   IF(LINE.EQ.' ') GO TO 50
   !
   !4A1----LOOK FOR "PERIOD", WHICH TERMINATES OUTPUT CONTROL FOR CURRENT
   !4A1----TIME STEP.  IF FOUND, DECODE TIME STEP FOR NEXT OUTPUT.
   LLOC=1
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
   IF(LINE(ISTART:ISTOP).EQ.'PERIOD') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IPEROC,R,IOUT,INOC)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).NE.'STEP') GO TO 2000
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ITSOC,R,IOUT,INOC)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'DDREFERENCE') THEN
         IDDREFNEW=1
      ELSE
         IDDREFNEW=0
      END IF
      RETURN
   !
   !4A2----LOOK FOR "PRINT", WHICH MAY REFER TO "BUDGET", "HEAD", OR
   !4A2----"DRAWDOWN".
   ELSE IF(LINE(ISTART:ISTOP).EQ.'PRINT') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'BUDGET') THEN
         WRITE(IOUT,53)
53       FORMAT(4X,'PRINT BUDGET')
         IBUDFL=1
      ELSE IF(LINE(ISTART:ISTOP).EQ.'HEAD') THEN
         CALL SGWF2BAS7L(1,LINE,LLOC,IOFLG,NLAY,IOUT,'PRINT HEAD',&
         &INOC)
         IHDDFL=1
      ELSE IF(LINE(ISTART:ISTOP).EQ.'DRAWDOWN') THEN
         CALL SGWF2BAS7L(2,LINE,LLOC,IOFLG,NLAY,IOUT,&
         &'PRINT DRAWDOWN',INOC)
         IHDDFL=1
      ELSE
         GO TO 2000
      END IF
   !
   !4A3----LOOK FOR "SAVE", WHICH MAY REFER TO "BUDGET", "HEAD",
   !4A3----"DRAWDOWN", OR "IBOUND".
   ELSE IF(LINE(ISTART:ISTOP).EQ.'SAVE') THEN
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INOC)
      IF(LINE(ISTART:ISTOP).EQ.'BUDGET') THEN
         WRITE(IOUT,57)
57       FORMAT(4X,'SAVE BUDGET')
         ICBCFL=IBDOPT
      ELSE IF(LINE(ISTART:ISTOP).EQ.'HEAD') THEN
         CALL SGWF2BAS7L(3,LINE,LLOC,IOFLG,NLAY,IOUT,'SAVE HEAD',&
         &INOC)
         IHDDFL=1
      ELSE IF(LINE(ISTART:ISTOP).EQ.'DRAWDOWN') THEN
         CALL SGWF2BAS7L(4,LINE,LLOC,IOFLG,NLAY,IOUT,'SAVE DRAWDOWN',&
         &INOC)
         IHDDFL=1
      ELSE IF(LINE(ISTART:ISTOP).EQ.'IBOUND') THEN
         CALL SGWF2BAS7L(5,LINE,LLOC,IOFLG,NLAY,IOUT,'SAVE IBOUND',&
         &INOC)
         IHDDFL=1
      ELSE
         GO TO 2000
      END IF
   !
   !4A4----WHEN NO KNOWN ALPHABETIC WORDS ARE FOUND, THERE IS AN ERROR.
   ELSE
      GO TO 2000
   !
   !4B-----AFTER SUCCESSFULLY DECODING ONE RECORD, READ ANOTHER.
   END IF
   GO TO 50
   !
   !5------END OF FILE WHILE READING AN OUTPUT CONTROL RECORD, SO THERE
   !5------WILL BE NO FURTHER OUTPUT.  SET IPEROC AND ITSOC HIGH ENOUGH
   !5------THAT THE MODEL TIME WILL NEVER MATCH THEM.
1000 IPEROC=9999
   ITSOC=9999
   RETURN
   !
   !6------ERROR DECODING ALPHABETIC INPUT STRUCTURE.
2000 WRITE(IOUT,2001) LINE
2001 FORMAT(1X,/1X,'ERROR READING OUTPUT CONTROL INPUT DATA:'/1X,A80)
   CALL USTOP(' ')
END
SUBROUTINE SGWF2BAS7L(IPOS,LINE,LLOC,IOFLG,NLAY,IOUT,LABEL,INOC)
   !     ******************************************************************
   !     WHEN USING ALPHABETIC OUTPUT CONTROL, DECODE LAYER
   !     NUMBERS FOR PRINTING OR SAVING HEAD OR DRAWDOWN
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   DIMENSION IOFLG(NLAY,5)
   CHARACTER*200 LINE
   CHARACTER*(*) LABEL
   DIMENSION LAYER(999)
   !     ------------------------------------------------------------------
   !
   !1------INITIALIZE COUNTER FOR NUMBER OF LAYERS FOR WHICH OUTPUT IS
   !1------SPECIFIED.
   NSET=0
   !
   !2------CHECK FOR A VALID LAYER NUMBER.  WHEN FOUND, SET FLAG AND
   !2------REPEAT.
10 CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,L,R,-1,INOC)
   IF(L.GT.0 .AND. L.LE.NLAY) THEN
      NSET=NSET+1
      LAYER(NSET)=L
      IOFLG(L,IPOS)=1
      GO TO 10
   END IF
   !
   !3------DONE CHECKING FOR LAYER NUMBERS.  IF NO LAYER NUMBERS WERE
   !3------FOUND, SET FLAGS FOR ALL LAYERS.
   IF(NSET.EQ.0) THEN
      DO 110 K=1,NLAY
         IOFLG(K,IPOS)=1
110   CONTINUE
      WRITE(IOUT,111) LABEL
111   FORMAT(4X,A,' FOR ALL LAYERS')
   !
   !4------IF ONE OR MORE LAYER NUMBERS WERE FOUND, PRINT THE NUMBERS.
   ELSE
      WRITE(IOUT,112) LABEL,(LAYER(M),M=1,NSET)
112   FORMAT(4X,A,' FOR LAYERS:',(1X,15I3))
   END IF
   !
   !5------RETURN.
   RETURN
END
SUBROUTINE SGWF2BAS7OPEN(INUNIT,IOUT,IUNIT,CUNIT,&
&NIUNIT,VERSION,INBAS,MAXUNIT,MFVNAM)
   !     ******************************************************************
   !     OPEN FILES.
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   use openspec
   DIMENSION IUNIT(NIUNIT)
   CHARACTER*4 CUNIT(NIUNIT)
   CHARACTER*7 FILSTAT
   CHARACTER*20 FILACT, FMTARG, ACCARG
   CHARACTER*(*) VERSION,MFVNAM
   CHARACTER*40 SPACES
   CHARACTER*300 LINE, FNAME
   CHARACTER*20 FILTYP
   LOGICAL LOP
   !     ---------------------------------------------------------------
   !
   !1------INITIALIZE CONSTANTS.
   INBAS=0
   NFILE=0
   IOUT=0
   DO 5 I=1,NIUNIT
      IUNIT(I)=0
5  CONTINUE
   SPACES=' '
   LENVER=LEN_TRIM(VERSION)
   INDENT=40-(LENVER+8)/2
   !
   !2------READ A LINE; IGNORE BLANK LINES AND PRINT COMMENT LINES.
10 READ(INUNIT,'(A)',END=1000) LINE
   IF(LINE.EQ.' ') GO TO 10
   IF(LINE(1:1).EQ.'#') THEN
      IF(NFILE.NE.0 .AND. IOUT.NE.0) WRITE(IOUT,'(A)') LINE
      GO TO 10
   END IF
   !
   !3------DECODE THE FILE TYPE, UNIT NUMBER, AND NAME.
   LLOC=1
   CALL URWORD(LINE,LLOC,ITYP1,ITYP2,1,N,R,IOUT,INUNIT)
   FILTYP=LINE(ITYP1:ITYP2)
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,IU,R,IOUT,INUNIT)
   CALL URWORD(LINE,LLOC,INAM1,INAM2,0,N,R,IOUT,INUNIT)
   IFLEN=INAM2-INAM1+1
   FNAME(1:IFLEN)=LINE(INAM1:INAM2)
   INQUIRE(UNIT=IU,OPENED=LOP)
   IF(LOP) THEN
      IF(IOUT.EQ.0) THEN
         WRITE(*,11) FNAME(1:IFLEN),IU
11       FORMAT(1X,/1X,'CANNOT OPEN ',A,' ON UNIT',I4,&
         &' BECAUSE UNIT IS ALREADY BEING USED')
      ELSE
         WRITE(IOUT,11) FNAME(1:IFLEN),IU
      END IF
      CALL USTOP(' ')
   END IF
   !
   !4------KEEP TRACK OF LARGEST UNIT NUMBER
   IF (IU.GT.MAXUNIT) MAXUNIT = IU
   !
   !5------SET DEFAULT FILE ATTRIBUTES.
   FMTARG='FORMATTED'
   ACCARG='SEQUENTIAL'
   FILSTAT='UNKNOWN'
   FILACT=' '
   !
   !6------SPECIAL CHECK FOR 1ST FILE.
   IF(NFILE.EQ.0) THEN
      IF(FILTYP.EQ.'LIST') THEN
         IOUT=IU
         OPEN(UNIT=IU,FILE=FNAME(1:IFLEN),STATUS='REPLACE',&
         &FORM='FORMATTED',ACCESS='SEQUENTIAL')
         WRITE(IOUT,60) MFVNAM,SPACES(1:INDENT),VERSION(1:LENVER)
60       FORMAT(34X,'MODFLOW',A,/,&
         &6X,'U.S. GEOLOGICAL SURVEY MODULAR',&
         &' FINITE-DIFFERENCE GROUNDWATER-FLOW MODEL',/,&
         &A,'VERSION ',A,/,20X,'BASED ON MODFLOW-2005 VERSION '&
         &,'1.12.00 02/03/2017'/)
         WRITE(IOUT,78) FNAME(1:IFLEN),IOUT
78       FORMAT(1X,'LIST FILE: ',A,/25X,'UNIT ',I4)
      ELSE
         WRITE(*,*)&
         &' FIRST ENTRY IN NAME FILE MUST BE "LIST".'
         CALL USTOP(' ')
      END IF
   !  Get next file name
      NFILE=1
      GO TO 10
   END IF
   !
   !8------CHECK FOR "BAS" FILE TYPE.
   IF(FILTYP.EQ.'BAS6') THEN
      INBAS=IU
      FILSTAT='OLD    '
      FILACT=ACTION(1)
   !
   !9------CHECK FOR "UNFORMATTED" FILE TYPE.
   ELSE IF(FILTYP.EQ.'DATA(BINARY)' .OR.&
   &FILTYP.EQ.'DATAGLO(BINARY)') THEN
      FMTARG=FORM
      ACCARG=ACCESS
   !
   !10-----CHECK FOR "FORMATTED" FILE TYPE.
   ELSE IF(LINE(ITYP1:ITYP2).EQ.'DATA' .OR.&
   &LINE(ITYP1:ITYP2).EQ.'DATAGLO') THEN
      FMTARG='FORMATTED'
      ACCARG='SEQUENTIAL'
   !
   !11-----CHECK FOR MAJOR OPTIONS.
   ELSE
      DO 20 I=1,NIUNIT
         IF(LINE(ITYP1:ITYP2).EQ.CUNIT(I)) THEN
            IF ( LINE(ITYP1:ITYP1+4).EQ."IWRT" ) THEN  !next section modified for restart option !gsf
               IUNIT(I)=IU
               FILSTAT='UNKNOWN'
               FILACT=ACTION(2)
               FMTARG=FORM
               ACCARG=ACCESS
               GO TO 30
            ELSEIF ( LINE(ITYP1:ITYP1+4).EQ."IRED" ) THEN
               IUNIT(I)=IU
               FILSTAT='UNKNOWN'
               FILACT=ACTION(2)
               FMTARG=FORM
               ACCARG=ACCESS
               GO TO 30
            ELSE
               IUNIT(I)=IU
               FILSTAT='OLD    '
               FILACT=ACTION(1)
               GO TO 30
            END IF
         END IF
20    CONTINUE
      WRITE(IOUT,21) LINE(ITYP1:ITYP2)
21    FORMAT(1X,'ILLEGAL FILE TYPE IN NAME FILE: ',A)
      CALL USTOP(' ')
30    CONTINUE
   END IF
   !
   !12-----FOR DATA FILES, CHECK FOR "REPLACE" OR "OLD" OPTION
   IF (FILSTAT.EQ.'UNKNOWN') THEN
      CALL URWORD(LINE,LLOC,IOPT1,IOPT2,1,N,R,IOUT,INUNIT)
      IF (LINE(IOPT1:IOPT2).EQ.'REPLACE' .OR.&
      &LINE(IOPT1:IOPT2).EQ.'OLD')&
      &FILSTAT = LINE(IOPT1:IOPT2)
   ENDIF
   !12A----Open file as read-only when 'OLD' is present to allow parallel
   !12A----model runs to read data from file simultaneously.
   IF (FILACT.EQ.' ') THEN
      IF (FILSTAT.EQ.'OLD') THEN
         FILACT=ACTION(1)
      ELSE
         FILACT=ACTION(2)
      ENDIF
   ENDIF
   !
   !13-----WRITE THE FILE NAME AND OPEN IT.
   WRITE(IOUT,50) FNAME(1:IFLEN),&
   &LINE(ITYP1:ITYP2),IU,FILSTAT,FMTARG,ACCARG
50 FORMAT(1X,/1X,'OPENING ',A,/&
   &1X,'FILE TYPE:',A,'   UNIT ',I4,3X,'STATUS:',A,/&
   &1X,'FORMAT:',A,3X,'ACCESS:',A)
   OPEN(UNIT=IU,FILE=FNAME(1:IFLEN),FORM=FMTARG,&
   &ACCESS=ACCARG,STATUS=FILSTAT,ACTION=FILACT,ERR=2000)
   NFILE=NFILE+1
   GO TO 10
   !
   !14-----END OF NAME FILE.  RETURN PROVIDED THAT LISTING FILE AND BAS
   !14-----FILES HAVE BEEN OPENED.
1000 IF(NFILE.EQ.0) THEN
      WRITE(*,*) ' NAME FILE IS EMPTY.'
      CALL USTOP(' ')
   ELSE IF(INBAS.EQ.0) THEN
      WRITE(IOUT,*) ' BAS PACKAGE FILE HAS NOT BEEN OPENED.'
      CALL USTOP(' ')
   END IF
   CLOSE (UNIT=INUNIT)
   !
   RETURN
   !
   !15-----ERROR OPENING FILE.
2000 CONTINUE
   WRITE(*,2010)FNAME(1:IFLEN),IU,FILSTAT,FMTARG,ACCARG,FILACT
   WRITE(IOUT,2010)FNAME(1:IFLEN),IU,FILSTAT,FMTARG,ACCARG,FILACT
2010 FORMAT(/,1X,'*** ERROR OPENING FILE "',A,'" ON UNIT ',I5,/,&
   &7X,'SPECIFIED FILE STATUS: ',A,/&
   &7X,'SPECIFIED FILE FORMAT: ',A,/&
   &7X,'SPECIFIED FILE ACCESS: ',A,/&
   &7X,'SPECIFIED FILE ACTION: ',A,/&
   &2X,'-- STOP EXECUTION (SGWF2BAS7OPEN)')
   CALL USTOP(' ')
   !
END
SUBROUTINE SGWF2BAS7ARMZ(INZONE,INMULT)
   !     ******************************************************************
   !     ALLOCATE AND READ MULTIPLIER AND ZONE ARRAYS
   !     ******************************************************************
   !
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,     ONLY:NCOL,NROW,IOUT
   USE PARAMMODULE,ONLY:NZONAR,NMLTAR,ZONNAM,MLTNAM,IZON,RMLT
   !
   CHARACTER*20 RW
   CHARACTER*1 COP
   CHARACTER*24 ANAME
   CHARACTER*10 CTMP1,CTMP2
   CHARACTER*200 LINE
   !     ------------------------------------------------------------------
   !
   !1------Read Number of Zone Arrays if Zone Option is active.
   NZONAR=0
   IF(INZONE.GT.0) THEN
      WRITE(IOUT,1) INZONE
1     FORMAT(1X,/1X,'ZONE OPTION, INPUT READ FROM UNIT ',I4)
      CALL URDCOM(INZONE,IOUT,LINE)
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NZONAR,R,IOUT,INZONE)
      WRITE(IOUT,2) NZONAR
2     FORMAT(1X,I5,' ZONE ARRAYS')
      IF(NZONAR.LT.0) NZONAR=0
   END IF
   !
   !2------Allocate memory for zone arrays.  Allocate one array element if
   !2------there are no zone arrays.
   IF(NZONAR.GT.0) THEN
      ALLOCATE (ZONNAM(NZONAR))
      ALLOCATE (IZON(NCOL,NROW,NZONAR))
   ELSE
      ALLOCATE (ZONNAM(1))
      ALLOCATE (IZON(1,1,1))
   ENDIF
   !
   !3------Read Number of Multiplier Arrays if Multiplier Option is active.
   NMLTAR=0
   IF(INMULT.GT.0) THEN
      WRITE(IOUT,11) INMULT
11    FORMAT(1X,/1X,'MULTIPLIER OPTION, INPUT READ FROM UNIT ',I4)
      CALL URDCOM(INMULT,IOUT,LINE)
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NMLTAR,R,IOUT,INMULT)
      WRITE(IOUT,12) NMLTAR
12    FORMAT(1X,I3,' MULTIPLIER ARRAYS')
      IF(NMLTAR.LT.0) NMLTAR=0
   END IF
   !
   !4------Allocate memory for multiplier arrays.  Allocate one array element if
   !4------there are no multiplier arrays.
   IF(NMLTAR.GT.0) THEN
      ALLOCATE (MLTNAM(NMLTAR))
      ALLOCATE (RMLT(NCOL,NROW,NMLTAR))
   ELSE
      ALLOCATE (MLTNAM(1))
      ALLOCATE (RMLT(1,1,1))
   ENDIF
   !
   !5------Initialize names of zones, multipliers, and parameters.
   IF(NZONAR.GT.0) THEN
      DO 10 I=1,NZONAR
         ZONNAM(I)=' '
10    CONTINUE
   END IF
   IF(NMLTAR.GT.0) THEN
      DO 20 I=1,NMLTAR
         MLTNAM(I)=' '
20    CONTINUE
   END IF
   !
   !6------Define the multiplier arrays.
   IF(NMLTAR.GT.0) THEN
      DO 2000 M=1,NMLTAR
   !
   !6A-----Read a line describing a multiplier array.
         READ (INMULT,'(A)') LINE
   !
   !6B-----Get the name of the new array
         LLOC=1
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INMULT)
   !
   !6C-----Add new multiplier name into list.
         MLTNAM(M)=LINE(ISTART:ISTOP)
         CALL URWORD(LINE,LLOC,ISTART,ISTOP,1,N,R,IOUT,INMULT)
         IF(LINE(ISTART:ISTOP).NE.'FUNCTION') THEN
   !
   !6D-----Define array using array reader.
            ANAME=' MULT. ARRAY: '//MLTNAM(M)
            CALL U2DREL(RMLT(:,:,M),ANAME,NROW,NCOL,0,INMULT,IOUT)
         ELSE
   !
   !6E-----Define array as aritmetic combination of other multiplier arrays.
   !6E-----Start by initializing the array to 0.
            WRITE(IOUT,30) MLTNAM(M)
30          FORMAT(1X,/1X,'Calculated multiplier array: ',A)
            DO 40 I=1,NROW
               DO 40 J=1,NCOL
                  RMLT(J,I,M)=0.
40          CONTINUE
   !
   !6E1----Get the names of the multipliers and the operands.
            READ (INMULT,'(A)') LINE
            LLOC=1
            NOP=0
   !
   !6E2----Get the operator.
45          IF(NOP.EQ.0) THEN
   !
   !6E2A---No operator is specified before the first operand -- define it to be " "
               COP=' '
            ELSE
   !
   !6E2B---Get the operator that precedes each operand after the first operand.
               CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INMULT)
               IF(LINE(ISTART:ISTOP).EQ.'+' .OR.&
               &LINE(ISTART:ISTOP).EQ.'-' .OR.&
               &LINE(ISTART:ISTOP).EQ.'*' .OR.&
               &LINE(ISTART:ISTOP).EQ.'/') THEN
                  COP=LINE(ISTART:ISTOP)
               ELSE
                  GO TO 1000
               END IF
            END IF
            NOP=NOP+1
   !
   !6E3----Get the operand.
            CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,N,R,IOUT,INMULT)
            WRITE(IOUT,47 ) COP,LINE(ISTART:ISTOP)
47          FORMAT(1X,'                        ',A,' ARRAY ',A)
   !
   !6E4----Lookup the operand in the list of existing multipliers
            CTMP2=LINE(ISTART:ISTOP)
            CALL UPCASE(CTMP2)
            DO 50 MM=1,M-1
               CTMP1=MLTNAM(MM)
               CALL UPCASE(CTMP1)
               IF(CTMP1.EQ.CTMP2) GO TO 60
50          CONTINUE
            WRITE(IOUT,51) LINE(ISTART:ISTOP)
51          FORMAT(1X,&
            &'ARRAY OPERAND HAS NOT BEEN PREVIOUSLY DEFINED:',A)
            CALL USTOP(' ')
   !
   !6E5----Apply the + operator.
60          IF(COP.EQ.'+' .OR. COP.EQ.' ') THEN
               DO 100 I = 1, NROW
                  DO 100 J = 1, NCOL
                     RMLT(J,I,M) = RMLT(J,I,M)+ RMLT(J,I,MM)
100            CONTINUE
            ELSE IF(COP.EQ.'-') THEN
               DO 200 I = 1, NROW
                  DO 200 J = 1, NCOL
                     RMLT(J,I,M) = RMLT(J,I,M)- RMLT(J,I,MM)
200            CONTINUE
            ELSE IF(COP.EQ.'*') THEN
               DO 300 I = 1, NROW
                  DO 300 J = 1, NCOL
                     RMLT(J,I,M) = RMLT(J,I,M)* RMLT(J,I,MM)
300            CONTINUE
            ELSE
               DO 400 I = 1, NROW
                  DO 400 J = 1, NCOL
                     RMLT(J,I,M) = RMLT(J,I,M)/ RMLT(J,I,MM)
400            CONTINUE
            END IF
   !
   !6E6----Get the next operator.
            GO TO 45
   !
   !6E7-----Done defining the array.  Get the print code and print the array.
1000        IPRN=0
            L=20-ISTOP+ISTART
            IF(L.GT.1)  THEN
               RW=' '
               RW(L:20)=LINE(ISTART:ISTOP)
               READ(RW,'(I20)',ERR=1200) IPRN
            END IF
1200        IF(IPRN.GE.0) THEN
               ANAME=' MULT. ARRAY: '//MLTNAM(M)
               CALL ULAPRWC(RMLT(:,:,M),NCOL,NROW,0,IOUT,IPRN,&
               &ANAME)
            END IF
         END IF
2000  CONTINUE
   ENDIF
   !
   !7------Read the zone array names and arrays
   IF(NZONAR.GT.0) THEN
      DO 3000 NZ=1,NZONAR
         READ(INZONE,'(A)') ZONNAM(NZ)
         CALL U2DINT(IZON(:,:,NZ),'  ZONE ARRAY: '//ZONNAM(NZ),&
         &NROW,NCOL,0,INZONE,IOUT)
3000  CONTINUE
   END IF
   !
   !8------Return.
   RETURN
END
SUBROUTINE SGWF2BAS7ARPVAL(IUPVAL)
   !     ******************************************************************
   !     READ PARAMETER INPUT FILE
   !     ******************************************************************
   !     SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,    ONLY: IOUT,IUNIT
   USE PARAMMODULE, ONLY:MXPAR,IPSUM,PARNAM,B,NPVAL
   !
   CHARACTER*10 PNI, PNJ
   CHARACTER*200 LINE
   !     ------------------------------------------------------------------
   !
   !1------CHECK TO SEE IF THE PARAMETER FILE WAS DECLARED IN THE NAME FILE.
   IU=IUNIT(IUPVAL)
   IF(IU.LE.0) THEN
      NPVAL=0
      RETURN
   END IF
   !
   !2------INITIALIZE VARIABLES
   IERR = 0
   NPE = 0
   !
   !3------IDENTIFY PARAMETER VALUE OPTION.
   WRITE (IOUT,12) IU
12 FORMAT (1X,/,1X,&
   &'PARAMETER VALUE INPUT FILE,  INPUT READ FROM UNIT ',I4)
   !
   !4------READ & PRINT NUMBER OF PARAMETER VALUES.
   CALL URDCOM(IU,IOUT,LINE)
   LLOC = 1
   CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPVAL,DUM,IOUT,IU)
   WRITE (IOUT,14) NPVAL
14 FORMAT (1X,/,1X,'NUMBER OF PARAMETER VALUES TO BE READ FROM',&
   &' PARAMETER VALUE FILE:',I5)
   IF (NPVAL.LE.0) THEN
      WRITE (IOUT,16)
16    FORMAT(1X,'NPVAL IN PARAMETER INPUT FILE MUST BE',&
      &' > 0 -- STOP EXECUTION')
      CALL USTOP(' ')
   ENDIF
   IPSUM=NPVAL
   !
   !5-----DEACTIVATE OPTION IF THERE ARE NO PARAMETERS IN FILE.
   IF(NPVAL.LE.0) THEN
      WRITE(IOUT,*) ' NPVAL in parameter file is 0,',&
      &' so ignoring the parameter file'
      CLOSE(UNIT=IU)
      IU=0
      RETURN
   END IF
   !
   !6------STOP IF THERE ARE MORE THAN THE MAXIMUM NUMBER OF PARAMETERS.
   IF(NPVAL.GT.MXPAR) THEN
      WRITE(IOUT,*) ' PARAMETER FILE CONTAINS',NPVAL,&
      &' VALUES, BUT THE MAXIMUM NUMBER OF PARAMETERS IS',MXPAR
      CALL USTOP(' ')
   END IF
   !
   !7------WRITE A HEADING FOR THE LIST OF PARAMETERS.
   WRITE (IOUT,520)
520 FORMAT (/,' INFORMATION ON PARAMETERS LISTED IN PARAMETER FILE',/,&
   &13X,'  VALUE IN',/,&
   &'    NAME     PARAMETER FILE',/,&
   &' ----------  --------------')
   !
   !8-----READ AND WRITE PARAMETER NAMES AND VALUES.
   DO 70 I=1,NPVAL
      READ(IU,*,ERR=80) PARNAM(I),B(I)
      WRITE(IOUT,570) PARNAM(I),B(I)
570   FORMAT(1X,A10,2X,G12.5)
   !
   !8A-----CHECK FOR DUPLICATE PARAMETER NAME FOR ALL BUT THE FIRST PARAMETER.
      IF (I.GT.1) THEN
         PNI=PARNAM(I)
         CALL UPCASE(PNI)
         IM1 = I-1
         DO 60 J=1,IM1
            PNJ=PARNAM(J)
            CALL UPCASE(PNJ)
            IF (PNI.EQ.PNJ) THEN
               WRITE(IOUT,500) PARNAM(I)
500            FORMAT (' PARAMETER "',A10,&
               &'" IS LISTED MORE THAN ONCE IN PARAMETER FILE',/,&
               &' -- STOP EXECUTION')
               IERR = 1
            ENDIF
60       CONTINUE
      ENDIF
70 CONTINUE
   !
   !9------WRITE A MESSAGE EXPLAINING THAT THE PARAMETER VALUES REPLACE THE
   !9------VALUES FROM PACKAGE INPUT FILES..
   WRITE (IOUT,620)
620 FORMAT(1X,77('-'))
   WRITE (IOUT,630)
630 FORMAT(' FOR THE PARAMETERS LISTED IN THE TABLE ABOVE,',&
   &' PARAMETER VALUES IN INDIVIDUAL',/,&
   &' PACKAGE INPUT FILES ARE REPLACED BY THE VALUES FROM',&
   &' THE PARAMETER INPUT FILE.')
   !
   !10-----STOP IF THERE WERE DUPLICATE NAMES.
   IF (IERR.GT.0) THEN
      WRITE(IOUT,680)
680   FORMAT(/,&
      &' ERROR FOUND IN PARAMETER INPUT FILE.  SEARCH ABOVE',/,&
      &' FOR "STOP EXECUTION"')
      CALL USTOP(' ')
   ENDIF
   !
   !11-----CLOSE FILE AND RETURN.
   CLOSE(UNIT=IU)
   RETURN
   !
   !
80 WRITE(IOUT,590)
590 FORMAT(1X,/,1X,&
   &'ERROR ENCOUNTERED IN READING PARAMETER INPUT FILE',/,&
   &' -- STOP EXECUTION')
   CALL USTOP(' ')
   !
END
SUBROUTINE SGWF2BAS7STPVAL()
   !     ******************************************************************
   !     CHECK THAT PARAMETER DEFINITIONS ARE COMPLETE.
   !     ******************************************************************
   !        SPECIFICATIONS:
   !     ------------------------------------------------------------------
   USE GLOBAL,      ONLY: IOUT
   USE PARAMMODULE, ONLY:NPVAL,PARTYP,PARNAM
   !     ------------------------------------------------------------------
   IF(NPVAL.LE.0) RETURN
   IERR=0
   !
   !x------CHECK THAT ALL PARAMETERS IN PARAMETER INPUT FILE HAVE BEEN DEFINED.
   DO 90 IP=1,NPVAL
      IF (PARTYP(IP).EQ.' ') THEN
         IERR = 1
         WRITE(IOUT,110) PARNAM(IP)
110      FORMAT(1X,/,1X,'PARAMETER "',A10,&
         &'" IN PARAMETER INPUT FILE HAS NOT BEEN DEFINED',/,&
         &' -- STOP EXECUTION')
      ENDIF
90 CONTINUE
   !
   IF(IERR.NE.0) CALL USTOP(' ')
   !
   !x------RETURN.
   RETURN
END
SUBROUTINE GWF2BAS7DA(IGRID)
   !  DEALLOCATE GLOBAL DATA
   USE GLOBAL
   USE PARAMMODULE
   USE GWFBASMODULE
   !
   DEALLOCATE(GLOBALDAT(IGRID)%NCOL)
   DEALLOCATE(GLOBALDAT(IGRID)%NROW)
   DEALLOCATE(GLOBALDAT(IGRID)%NLAY)
   DEALLOCATE(GLOBALDAT(IGRID)%NPER)
   DEALLOCATE(GLOBALDAT(IGRID)%NBOTM)
   DEALLOCATE(GLOBALDAT(IGRID)%NCNFBD)
   DEALLOCATE(GLOBALDAT(IGRID)%ITMUNI)
   DEALLOCATE(GLOBALDAT(IGRID)%LENUNI)
   DEALLOCATE(GLOBALDAT(IGRID)%IXSEC)
   DEALLOCATE(GLOBALDAT(IGRID)%ITRSS)
   DEALLOCATE(GLOBALDAT(IGRID)%INBAS)
   DEALLOCATE(GLOBALDAT(IGRID)%IFREFM)
   DEALLOCATE(GLOBALDAT(IGRID)%NODES)
   DEALLOCATE(GLOBALDAT(IGRID)%IOUT)
   DEALLOCATE(GLOBALDAT(IGRID)%MXITER)
   !
   DEALLOCATE(GLOBALDAT(IGRID)%IUNIT)
   DEALLOCATE(GLOBALDAT(IGRID)%LAYCBD)
   DEALLOCATE(GLOBALDAT(IGRID)%LAYHDT)
   DEALLOCATE(GLOBALDAT(IGRID)%LAYHDS)
   DEALLOCATE(GLOBALDAT(IGRID)%PERLEN)
   DEALLOCATE(GLOBALDAT(IGRID)%NSTP)
   DEALLOCATE(GLOBALDAT(IGRID)%TSMULT)
   DEALLOCATE(GLOBALDAT(IGRID)%ISSFLG)
   DEALLOCATE(GLOBALDAT(IGRID)%DELR)
   DEALLOCATE(GLOBALDAT(IGRID)%DELC)
   DEALLOCATE(GLOBALDAT(IGRID)%BOTM)
   DEALLOCATE(GLOBALDAT(IGRID)%LBOTM)
   DEALLOCATE(GLOBALDAT(IGRID)%HNEW)
   DEALLOCATE(GLOBALDAT(IGRID)%HOLD)
   DEALLOCATE(GLOBALDAT(IGRID)%IBOUND)
   DEALLOCATE(GLOBALDAT(IGRID)%CR)
   DEALLOCATE(GLOBALDAT(IGRID)%CC)
   DEALLOCATE(GLOBALDAT(IGRID)%CV)
   DEALLOCATE(GLOBALDAT(IGRID)%HCOF)
   DEALLOCATE(GLOBALDAT(IGRID)%RHS)
   DEALLOCATE(GLOBALDAT(IGRID)%BUFF)
   DEALLOCATE(GLOBALDAT(IGRID)%STRT)
   IF(.NOT.ASSOCIATED(DDREF,STRT))&
   &DEALLOCATE(GLOBALDAT(IGRID)%DDREF)
   !
   DEALLOCATE(ICLSUM,IPSUM,INAMLOC,NMLTAR,NZONAR,NPVAL)
   DEALLOCATE (PARAMDAT(IGRID)%B)
   DEALLOCATE (PARAMDAT(IGRID)%IACTIVE)
   DEALLOCATE (PARAMDAT(IGRID)%IPLOC)
   DEALLOCATE (PARAMDAT(IGRID)%IPCLST)
   DEALLOCATE (PARAMDAT(IGRID)%PARNAM)
   DEALLOCATE (PARAMDAT(IGRID)%PARTYP)
   DEALLOCATE (PARAMDAT(IGRID)%ZONNAM)
   DEALLOCATE (PARAMDAT(IGRID)%MLTNAM)
   DEALLOCATE (PARAMDAT(IGRID)%INAME)
   DEALLOCATE (PARAMDAT(IGRID)%RMLT)
   DEALLOCATE (PARAMDAT(IGRID)%IZON)
   !
   DEALLOCATE(GWFBASDAT(IGRID)%MSUM)
   DEALLOCATE(GWFBASDAT(IGRID)%IHEDFM)
   DEALLOCATE(GWFBASDAT(IGRID)%IHEDUN)
   DEALLOCATE(GWFBASDAT(IGRID)%IDDNFM)
   DEALLOCATE(GWFBASDAT(IGRID)%IDDNUN)
   DEALLOCATE(GWFBASDAT(IGRID)%IBOUUN)
   DEALLOCATE(GWFBASDAT(IGRID)%LBHDSV)
   DEALLOCATE(GWFBASDAT(IGRID)%LBDDSV)
   DEALLOCATE(GWFBASDAT(IGRID)%LBBOSV)
   DEALLOCATE(GWFBASDAT(IGRID)%IBUDFL)
   DEALLOCATE(GWFBASDAT(IGRID)%ICBCFL)
   DEALLOCATE(GWFBASDAT(IGRID)%IHDDFL)
   DEALLOCATE(GWFBASDAT(IGRID)%IAUXSV)
   DEALLOCATE(GWFBASDAT(IGRID)%IBDOPT)
   DEALLOCATE(GWFBASDAT(IGRID)%IPRTIM)
   DEALLOCATE(GWFBASDAT(IGRID)%IPEROC)
   DEALLOCATE(GWFBASDAT(IGRID)%ITSOC)
   DEALLOCATE(GWFBASDAT(IGRID)%ICHFLG)
   DEALLOCATE(GWFBASDAT(IGRID)%IDDREF)
   DEALLOCATE(GWFBASDAT(IGRID)%IDDREFNEW)
   DEALLOCATE(GWFBASDAT(IGRID)%DELT)
   DEALLOCATE(GWFBASDAT(IGRID)%PERTIM)
   DEALLOCATE(GWFBASDAT(IGRID)%TOTIM)
   DEALLOCATE(GWFBASDAT(IGRID)%HNOFLO)
   DEALLOCATE(GWFBASDAT(IGRID)%HDRY)
   DEALLOCATE(GWFBASDAT(IGRID)%STOPER)
   DEALLOCATE(GWFBASDAT(IGRID)%CHEDFM)
   DEALLOCATE(GWFBASDAT(IGRID)%CDDNFM)
   DEALLOCATE(GWFBASDAT(IGRID)%CBOUFM)
   !
   DEALLOCATE(GWFBASDAT(IGRID)%IOFLG)
   DEALLOCATE(GWFBASDAT(IGRID)%VBVL)
   DEALLOCATE(GWFBASDAT(IGRID)%VBNM)
   !
   RETURN
END
SUBROUTINE SGWF2BAS7PNT(IGRID)
   !  Change global data to a different grid.
   USE GLOBAL
   USE PARAMMODULE
   USE GWFBASMODULE
   !
   NCOL=>GLOBALDAT(IGRID)%NCOL
   NROW=>GLOBALDAT(IGRID)%NROW
   NLAY=>GLOBALDAT(IGRID)%NLAY
   NPER=>GLOBALDAT(IGRID)%NPER
   NBOTM=>GLOBALDAT(IGRID)%NBOTM
   NCNFBD=>GLOBALDAT(IGRID)%NCNFBD
   ITMUNI=>GLOBALDAT(IGRID)%ITMUNI
   LENUNI=>GLOBALDAT(IGRID)%LENUNI
   IXSEC=>GLOBALDAT(IGRID)%IXSEC
   ITRSS=>GLOBALDAT(IGRID)%ITRSS
   INBAS=>GLOBALDAT(IGRID)%INBAS
   IFREFM=>GLOBALDAT(IGRID)%IFREFM
   NODES=>GLOBALDAT(IGRID)%NODES
   IOUT=>GLOBALDAT(IGRID)%IOUT
   MXITER=>GLOBALDAT(IGRID)%MXITER
   !
   IUNIT=>GLOBALDAT(IGRID)%IUNIT
   LAYCBD=>GLOBALDAT(IGRID)%LAYCBD
   LAYHDT=>GLOBALDAT(IGRID)%LAYHDT
   LAYHDS=>GLOBALDAT(IGRID)%LAYHDS
   PERLEN=>GLOBALDAT(IGRID)%PERLEN
   NSTP=>GLOBALDAT(IGRID)%NSTP
   TSMULT=>GLOBALDAT(IGRID)%TSMULT
   ISSFLG=>GLOBALDAT(IGRID)%ISSFLG
   DELR=>GLOBALDAT(IGRID)%DELR
   DELC=>GLOBALDAT(IGRID)%DELC
   BOTM=>GLOBALDAT(IGRID)%BOTM
   LBOTM=>GLOBALDAT(IGRID)%LBOTM
   HNEW=>GLOBALDAT(IGRID)%HNEW
   HOLD=>GLOBALDAT(IGRID)%HOLD
   IBOUND=>GLOBALDAT(IGRID)%IBOUND
   CR=>GLOBALDAT(IGRID)%CR
   CC=>GLOBALDAT(IGRID)%CC
   CV=>GLOBALDAT(IGRID)%CV
   HCOF=>GLOBALDAT(IGRID)%HCOF
   RHS=>GLOBALDAT(IGRID)%RHS
   BUFF=>GLOBALDAT(IGRID)%BUFF
   STRT=>GLOBALDAT(IGRID)%STRT
   DDREF=>GLOBALDAT(IGRID)%DDREF
   !
   ICLSUM=>PARAMDAT(IGRID)%ICLSUM
   IPSUM=>PARAMDAT(IGRID)%IPSUM
   INAMLOC=>PARAMDAT(IGRID)%INAMLOC
   NMLTAR=>PARAMDAT(IGRID)%NMLTAR
   NZONAR=>PARAMDAT(IGRID)%NZONAR
   NPVAL=>PARAMDAT(IGRID)%NPVAL
   !
   B=>PARAMDAT(IGRID)%B
   IACTIVE=>PARAMDAT(IGRID)%IACTIVE
   IPLOC=>PARAMDAT(IGRID)%IPLOC
   IPCLST=>PARAMDAT(IGRID)%IPCLST
   IZON=>PARAMDAT(IGRID)%IZON
   RMLT=>PARAMDAT(IGRID)%RMLT
   PARNAM=>PARAMDAT(IGRID)%PARNAM
   PARTYP=>PARAMDAT(IGRID)%PARTYP
   ZONNAM=>PARAMDAT(IGRID)%ZONNAM
   MLTNAM=>PARAMDAT(IGRID)%MLTNAM
   INAME=>PARAMDAT(IGRID)%INAME
   !
   MSUM=>GWFBASDAT(IGRID)%MSUM
   IHEDFM=>GWFBASDAT(IGRID)%IHEDFM
   IHEDUN=>GWFBASDAT(IGRID)%IHEDUN
   IDDNFM=>GWFBASDAT(IGRID)%IDDNFM
   IDDNUN=>GWFBASDAT(IGRID)%IDDNUN
   IBOUUN=>GWFBASDAT(IGRID)%IBOUUN
   LBHDSV=>GWFBASDAT(IGRID)%LBHDSV
   LBDDSV=>GWFBASDAT(IGRID)%LBDDSV
   LBBOSV=>GWFBASDAT(IGRID)%LBBOSV
   IBUDFL=>GWFBASDAT(IGRID)%IBUDFL
   ICBCFL=>GWFBASDAT(IGRID)%ICBCFL
   IHDDFL=>GWFBASDAT(IGRID)%IHDDFL
   IAUXSV=>GWFBASDAT(IGRID)%IAUXSV
   IBDOPT=>GWFBASDAT(IGRID)%IBDOPT
   IPRTIM=>GWFBASDAT(IGRID)%IPRTIM
   IPEROC=>GWFBASDAT(IGRID)%IPEROC
   ITSOC=>GWFBASDAT(IGRID)%ITSOC
   ICHFLG=>GWFBASDAT(IGRID)%ICHFLG
   IDDREF=>GWFBASDAT(IGRID)%IDDREF
   IDDREFNEW=>GWFBASDAT(IGRID)%IDDREFNEW
   DELT=>GWFBASDAT(IGRID)%DELT
   PERTIM=>GWFBASDAT(IGRID)%PERTIM
   TOTIM=>GWFBASDAT(IGRID)%TOTIM
   HNOFLO=>GWFBASDAT(IGRID)%HNOFLO
   HDRY=>GWFBASDAT(IGRID)%HDRY
   STOPER=>GWFBASDAT(IGRID)%STOPER
   CHEDFM=>GWFBASDAT(IGRID)%CHEDFM
   CDDNFM=>GWFBASDAT(IGRID)%CDDNFM
   CBOUFM=>GWFBASDAT(IGRID)%CBOUFM
   !
   IOFLG=>GWFBASDAT(IGRID)%IOFLG
   VBVL=>GWFBASDAT(IGRID)%VBVL
   VBNM=>GWFBASDAT(IGRID)%VBNM
   !
   RETURN
END
SUBROUTINE SGWF2BAS7PSV(IGRID)
   !  Save global data for a grid.
   USE GLOBAL
   USE PARAMMODULE
   USE GWFBASMODULE
   !
   GLOBALDAT(IGRID)%NCOL=>NCOL
   GLOBALDAT(IGRID)%NROW=>NROW
   GLOBALDAT(IGRID)%NLAY=>NLAY
   GLOBALDAT(IGRID)%NPER=>NPER
   GLOBALDAT(IGRID)%NBOTM=>NBOTM
   GLOBALDAT(IGRID)%NCNFBD=>NCNFBD
   GLOBALDAT(IGRID)%ITMUNI=>ITMUNI
   GLOBALDAT(IGRID)%LENUNI=>LENUNI
   GLOBALDAT(IGRID)%IXSEC=>IXSEC
   GLOBALDAT(IGRID)%ITRSS=>ITRSS
   GLOBALDAT(IGRID)%INBAS=>INBAS
   GLOBALDAT(IGRID)%IFREFM=>IFREFM
   GLOBALDAT(IGRID)%NODES=>NODES
   GLOBALDAT(IGRID)%IOUT=>IOUT
   GLOBALDAT(IGRID)%MXITER=>MXITER
   !
   GLOBALDAT(IGRID)%IUNIT=>IUNIT
   GLOBALDAT(IGRID)%LAYCBD=>LAYCBD
   GLOBALDAT(IGRID)%LAYHDT=>LAYHDT
   GLOBALDAT(IGRID)%LAYHDS=>LAYHDS
   GLOBALDAT(IGRID)%PERLEN=>PERLEN
   GLOBALDAT(IGRID)%NSTP=>NSTP
   GLOBALDAT(IGRID)%TSMULT=>TSMULT
   GLOBALDAT(IGRID)%ISSFLG=>ISSFLG
   GLOBALDAT(IGRID)%DELR=>DELR
   GLOBALDAT(IGRID)%DELC=>DELC
   GLOBALDAT(IGRID)%BOTM=>BOTM
   GLOBALDAT(IGRID)%LBOTM=>LBOTM
   GLOBALDAT(IGRID)%HNEW=>HNEW
   GLOBALDAT(IGRID)%HOLD=>HOLD
   GLOBALDAT(IGRID)%IBOUND=>IBOUND
   GLOBALDAT(IGRID)%CR=>CR
   GLOBALDAT(IGRID)%CC=>CC
   GLOBALDAT(IGRID)%CV=>CV
   GLOBALDAT(IGRID)%HCOF=>HCOF
   GLOBALDAT(IGRID)%RHS=>RHS
   GLOBALDAT(IGRID)%BUFF=>BUFF
   GLOBALDAT(IGRID)%STRT=>STRT
   GLOBALDAT(IGRID)%DDREF=>DDREF
   !
   PARAMDAT(IGRID)%ICLSUM=>ICLSUM
   PARAMDAT(IGRID)%IPSUM=>IPSUM
   PARAMDAT(IGRID)%INAMLOC=>INAMLOC
   PARAMDAT(IGRID)%NMLTAR=>NMLTAR
   PARAMDAT(IGRID)%NZONAR=>NZONAR
   PARAMDAT(IGRID)%NPVAL=>NPVAL
   !
   PARAMDAT(IGRID)%B=>B
   PARAMDAT(IGRID)%IACTIVE=>IACTIVE
   PARAMDAT(IGRID)%IPLOC=>IPLOC
   PARAMDAT(IGRID)%IPCLST=>IPCLST
   PARAMDAT(IGRID)%IZON=>IZON
   PARAMDAT(IGRID)%RMLT=>RMLT
   PARAMDAT(IGRID)%PARNAM=>PARNAM
   PARAMDAT(IGRID)%PARTYP=>PARTYP
   PARAMDAT(IGRID)%ZONNAM=>ZONNAM
   PARAMDAT(IGRID)%MLTNAM=>MLTNAM
   PARAMDAT(IGRID)%INAME=>INAME
   !
   GWFBASDAT(IGRID)%MSUM=>MSUM
   GWFBASDAT(IGRID)%IHEDFM=>IHEDFM
   GWFBASDAT(IGRID)%IHEDUN=>IHEDUN
   GWFBASDAT(IGRID)%IDDNFM=>IDDNFM
   GWFBASDAT(IGRID)%IDDNUN=>IDDNUN
   GWFBASDAT(IGRID)%IBOUUN=>IBOUUN
   GWFBASDAT(IGRID)%LBHDSV=>LBHDSV
   GWFBASDAT(IGRID)%LBDDSV=>LBDDSV
   GWFBASDAT(IGRID)%LBBOSV=>LBBOSV
   GWFBASDAT(IGRID)%IBUDFL=>IBUDFL
   GWFBASDAT(IGRID)%ICBCFL=>ICBCFL
   GWFBASDAT(IGRID)%IHDDFL=>IHDDFL
   GWFBASDAT(IGRID)%IAUXSV=>IAUXSV
   GWFBASDAT(IGRID)%IBDOPT=>IBDOPT
   GWFBASDAT(IGRID)%IPRTIM=>IPRTIM
   GWFBASDAT(IGRID)%IPEROC=>IPEROC
   GWFBASDAT(IGRID)%ITSOC=>ITSOC
   GWFBASDAT(IGRID)%ICHFLG=>ICHFLG
   GWFBASDAT(IGRID)%IDDREF=>IDDREF
   GWFBASDAT(IGRID)%IDDREFNEW=>IDDREFNEW
   GWFBASDAT(IGRID)%DELT=>DELT
   GWFBASDAT(IGRID)%PERTIM=>PERTIM
   GWFBASDAT(IGRID)%TOTIM=>TOTIM
   GWFBASDAT(IGRID)%HNOFLO=>HNOFLO
   GWFBASDAT(IGRID)%HDRY=>HDRY
   GWFBASDAT(IGRID)%STOPER=>STOPER
   GWFBASDAT(IGRID)%CHEDFM=>CHEDFM
   GWFBASDAT(IGRID)%CDDNFM=>CDDNFM
   GWFBASDAT(IGRID)%CBOUFM=>CBOUFM
   !
   GWFBASDAT(IGRID)%IOFLG=>IOFLG
   GWFBASDAT(IGRID)%VBVL=>VBVL
   GWFBASDAT(IGRID)%VBNM=>VBNM
   !
   RETURN
END
